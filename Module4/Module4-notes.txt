1. Generators
a piece of specialized code able to produce a series of values, and to control the iteration process
very often called iterators

range() function is a generator, which is (in fact, again) an iterator.

function returns one value, generator returns a series of values and is (implicitly) invoked more than once.


2. Iterator protocol.
iterator protocol is a way in which an object should behave to conform to the rules
imposed by the context of the for and in statements.

iterator must provide two methods:
__iter__() which should return the object itself and which is invoked once (it's needed for Python to successfully start the iteration)
__next__() which is intended to return the next value (first, second, and so on) of the desired series
    if there are no more values to provide, the method should raise the StopIteration exception.

The object of the class may be used as an iterator when (and only when) it positively answers to the __iter__ invocation

sample iterator:
class Fib:
    def __init__(self, nn):
        self.__n = nn
        self.__i = 0
        self.__p1 = self.__p2 = 1

    def __iter__(self):
        print("Fib iter")
        return self

    def __next__(self):
        self.__i += 1
        if self.__i > self.__n:
            raise StopIteration
        if self.__i in [1, 2]:
            return 1
        ret = self.__p1 + self.__p2
        self.__p1, self.__p2 = self.__p2, ret
        return ret

class Class:
    def __init__(self, n):
        self.__iter = Fib(n)

    def __iter__(self):
        print("Class iter")
        return self.__iter;


object = Class(8)

for i in object:
    print(i)


3. The yield statement
The main discomfort it brings is the need to save the state of the iteration between subsequent __iter__ invocations.
This makes the code larger and less comprehensible.

def fun(n):
    for i in range(n):
        return i

such a function is not able to save and restore its state between subsequent invocations.

def fun(n):
    for i in range(n):
        yield i

This little amendment turns the function into a generator

This provides the value of the expression specified after the yield keyword, just like return, but doesn't lose the state of the function.
All the variables' values are frozen, and wait for the next invocation, when the execution is resumed (not taken from scratch,
like after return).

There is one important limitation:
such a function should not be invoked explicitly as - in fact - it isn't a function anymore; it's a generator object.
The invocation will return the object's identifier


4. How to build a generator

def fun(n):
    for i in range(n):
        yield i


for v in fun(5):
    print(v, end='')

>>>
0 1 2 3 4


5. Generators may also be used within list comprehensions
6. The list() function can transform a series of subsequent generator invocations into a real list
7. The context created by the 'in' operator allows you to use a generator

8. Fibonacci generator

def fibonacci(n):
    p = pp = 1
    for i in range(n):
        if i in [0, 1]:
            yield 1
        else:
            n = p + pp
            pp, p = p, n
            yield n

fibs = list(fibonacci(10))
print(fibs)


9. expression_one if condition else expression_two
the_list = []

for x in range(10):
    the_list.append(1 if x % 2 == 0 else 0)

it is not a conditional instruction. Moreover, it's not an instruction at all. It's an operator.


10. List comprehensions vs. generators
Just one change can turn any list comprehension into a generator. - It's the parentheses.

the_list = [1 if x % 2 == 0 else 0 for x in range(10)]
the_generator = (1 if x % 2 == 0 else 0 for x in range(10))

The code, however, when run, produces two identical lines:

But:
len(the_list) will evaluate to 10. len(the_generator) will raise an exception: TypeError: object of type 'generator' has no len()

Of course, saving either the list or the generator is not necessary - you can create them exactly in the place where you need them

!!!
Note: the same appearance of the output doesn't mean that both loops work in the same way.
In the first loop, the list is created (and iterated through) as a whole - it actually exists when the loop is being executed.
In the second loop, there is no list at all - there are only subsequent values produced by the generator, one by one.
!!!

https://edube.org/learn/pe-2/generators-and-closures-50





