1. Generators
a piece of specialized code able to produce a series of values, and to control the iteration process
very often called iterators

range() function is a generator, which is (in fact, again) an iterator.

function returns one value, generator returns a series of values and is (implicitly) invoked more than once.


2. Iterator protocol.
iterator protocol is a way in which an object should behave to conform to the rules
imposed by the context of the for and in statements.

iterator must provide two methods:
__iter__() which should return the object itself and which is invoked once (it's needed for Python to successfully start the iteration)
__next__() which is intended to return the next value (first, second, and so on) of the desired series
    if there are no more values to provide, the method should raise the StopIteration exception.

The object of the class may be used as an iterator when (and only when) it positively answers to the __iter__ invocation

sample iterator:
class Fib:
    def __init__(self, nn):
        self.__n = nn
        self.__i = 0
        self.__p1 = self.__p2 = 1

    def __iter__(self):
        print("Fib iter")
        return self

    def __next__(self):
        self.__i += 1
        if self.__i > self.__n:
            raise StopIteration
        if self.__i in [1, 2]:
            return 1
        ret = self.__p1 + self.__p2
        self.__p1, self.__p2 = self.__p2, ret
        return ret

class Class:
    def __init__(self, n):
        self.__iter = Fib(n)

    def __iter__(self):
        print("Class iter")
        return self.__iter;


object = Class(8)

for i in object:
    print(i)


3. The yield statement
The main discomfort it brings is the need to save the state of the iteration between subsequent __iter__ invocations.
This makes the code larger and less comprehensible.

def fun(n):
    for i in range(n):
        return i

such a function is not able to save and restore its state between subsequent invocations.

def fun(n):
    for i in range(n):
        yield i

This little amendment turns the function into a generator

This provides the value of the expression specified after the yield keyword, just like return, but doesn't lose the state of the function.
All the variables' values are frozen, and wait for the next invocation, when the execution is resumed (not taken from scratch,
like after return).

There is one important limitation:
such a function should not be invoked explicitly as - in fact - it isn't a function anymore; it's a generator object.
The invocation will return the object's identifier


4. How to build a generator

def fun(n):
    for i in range(n):
        yield i


for v in fun(5):
    print(v, end='')

>>>
0 1 2 3 4


5. Generators may also be used within list comprehensions
6. The list() function can transform a series of subsequent generator invocations into a real list
7. The context created by the 'in' operator allows you to use a generator

8. Fibonacci generator

def fibonacci(n):
    p = pp = 1
    for i in range(n):
        if i in [0, 1]:
            yield 1
        else:
            n = p + pp
            pp, p = p, n
            yield n

fibs = list(fibonacci(10))
print(fibs)


9. expression_one if condition else expression_two
the_list = []

for x in range(10):
    the_list.append(1 if x % 2 == 0 else 0)

it is not a conditional instruction. Moreover, it's not an instruction at all. It's an operator.


10. List comprehensions vs. generators
Just one change can turn any list comprehension into a generator. - It's the parentheses.

the_list = [1 if x % 2 == 0 else 0 for x in range(10)]
the_generator = (1 if x % 2 == 0 else 0 for x in range(10))

The code, however, when run, produces two identical lines:

But:
len(the_list) will evaluate to 10. len(the_generator) will raise an exception: TypeError: object of type 'generator' has no len()

Of course, saving either the list or the generator is not necessary - you can create them exactly in the place where you need them

!!!
Note: the same appearance of the output doesn't mean that both loops work in the same way.
In the first loop, the list is created (and iterated through) as a whole - it actually exists when the loop is being executed.
In the second loop, there is no list at all - there are only subsequent values produced by the generator, one by one.
!!!

https://edube.org/learn/pe-2/generators-and-closures-50


10. The lambda function
A lambda function is a function without a name (you can also call it an anonymous function).
Programmers use the lambda function to simplify the code, to make it clearer and easier to understand

lambda parameters: expression

two = lambda: 2
sqr = lambda x: x * x
pwr = lambda x, y: x ** y

for a in range(-2, 3):
    print(sqr(a), end=" ")
    print(pwr(a, two()))


the first lambda is an anonymous parameterless function that always returns 2
As we've assigned it to a variable named two, we can say that the function is not anonymous anymore, and we can use the name to invoke it.

the second one is a one-parameter anonymous function

the third lambda takes two parameters and returns the value of the first one raised to the power of the second one.


11. How to use lambdas and what for?
you can use them in their pure form - as anonymous parts of code intended to evaluate a result.

12. Lambdas and the map() function
map(func, *iterables) --> map object

the second map() argument may be any entity that can be iterated (e.g., a tuple, or just a generator)

map() can accept more than two arguments:
list(map(lambda x, y: x + y, [1,2,3], [3,4,5]))
>>> [4, 6, 8]

The map() function applies the function passed by its first argument to all its second argument's elements,
and returns an iterator delivering all subsequent function results.

You can use the resulting iterator in a loop, or convert it into a list using the list() function.

for x in map(lambda x: x * x, list_2):
    print(x, end=' ')


13. Lambdas and the filter() function
filter(function or None, iterable) --> filter object

Return an iterator yielding those items of iterable for which function(item)
is true. If function is None, return the items that are true.

it filters its second argument while being guided by directions flowing from the function specified as the first argument

The elements which return True from the function pass the filter - the others are rejected.

filtered = list(filter(lambda x: x > 0 and x % 2 == 0, data))


list(filter(None, [1,2,3,4,0]))
>>> [1, 2, 3, 4]


14. A brief look at closures
closure is a technique which allows the storing of values in spite of the fact
that the context in which they have been created does not exist anymore

def outer(par):
    loc = par

    def inner():
        return loc
    return inner

var = 1
fun = outer(var)
print(fun())

>>> 1

The function returned during the outer() invocation is a closure.

15. A brief look at closures: continued
A closure has to be invoked in exactly the same way in which it has been declared.
e.g.: the inner() function is parameterless, so we have to invoke it without arguments.

it is fully possible to declare a closure equipped with an arbitrary number of parameters,

you can create as many closures as you want using one and the same piece of code.


16. Key takeaways

1. An iterator is an object of a class providing at least two methods (not counting the constructor!):

__iter__() is invoked once when the iterator is created and returns the iterator's object itself;
__next__() is invoked to provide the next iteration's value and raises the StopIteration exception when the iteration comes to and end.

2. The yield statement can be used only inside functions. The yield statement suspends function execution and causes the
function to return the yield's argument as a result. Such a function cannot be invoked in a regular way â€“
its only purpose is to be used as a generator (i.e. in a context that requires a series of values, like a for loop.)


3. A conditional expression is an expression built using the if-else operator. For example:

print(True if 0 >=0 else False)


outputs True.


4. A list comprehension becomes a generator when used inside parentheses (used inside brackets, it produces a regular list). For example:

for x in (el * 2 for el in range(5)):
    print(x)

outputs 02468.


4. A lambda function is a tool for creating anonymous functions. For example:

def foo(x,f):
    return f(x)

print(foo(9, lambda x: x ** 0.5))


outputs 3.0.


5. The map(fun, list) function creates a copy of a list argument, and applies the fun function to all of its elements,
returning a generator that provides the new list content element by element. For example:

short_list = ['mython', 'python', 'fell', 'on', 'the', 'floor']
new_list = list(map(lambda s: s.title(), short_list))
print(new_list)


outputs ['Mython', 'Python', 'Fell', 'On', 'The', 'Floor'].


6. The filter(fun, list) function creates a copy of those list elements, which cause the fun function to return True.
The function's result is a generator providing the new list content element by element. For example:

short_list = [1, "Python", -1, "Monty"]
new_list = list(filter(lambda s: isinstance(s, str), short_list))
print(new_list)


outputs ['Python', 'Monty'].


7. A closure is a technique which allows the storing of values in spite of the fact that the context in which they have
been created does not exist anymore. For example:

def tag(tg):
    tg2 = tg
    tg2 = tg[0] + '/' + tg[1:]

    def inner(str):
        return tg + str + tg2
    return inner


b_tag = tag('<b>')
print(b_tag('Monty Python'))


outputs <b>Monty Python</b>



Exercise 1

What is the expected output of the following code?

class Vowels:
    def __init__(self):
        self.vow = "aeiouy "  # Yes, we know that y is not always considered a vowel.
        self.pos = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.pos == len(self.vow):
            raise StopIteration
        self.pos += 1
        return self.vow[self.pos - 1]


vowels = Vowels()
for v in vowels:
    print(v, end=' ')


Check
a e i o u y



Exercise 2

Write a lambda function, setting the least significant bit of its integer argument, and apply it to the map() function
to produce the string 1 3 3 5 on the console.

any_list = [1, 2, 3, 4]
even_list = # Complete the line here.
print(even_list)


Check
list(map(lambda n: n | 1, any_list))



Exercise 3

What is the expected output of the following code?

def replace_spaces(replacement='*'):
    def new_replacement(text):
        return text.replace(' ', replacement)
    return new_replacement


stars = replace_spaces()
print(stars("And Now for Something Completely Different"))


Check
And*Now*for*Something*Completely*Different

Note

PEP 8, the Style Guide for Python Code, recommends that lambdas should not be assigned to variables, but rather they should be defined as functions.

This means that it is better to use a def statement, and avoid using an assignment statement that binds a lambda expression to an identifer. For example:

# Recommended:
def f(x): return 3*x


# Not recommended:
f = lambda x: 3*x


Binding lambdas to identifiers generally duplicates the functionality of the def statement. Using def statements,
on the other hand, generates more lines of code.

It is important to understand that reality often likes to draw its own scenarios, which do not necessarily follow the
conventions or formal recommendations. Whether you decide to follow them or not will depend on many things: your preferences,
other conventions adopted, company internal guidelines, compatibility with existing code, etc. Be aware of this.


17. Accessing files from Python code
If we want to implement a simple database, the only way to store the information between program runs is to save it
into a file (or files if your database is more complex).

Windows: C:\directory\file
Unix: /directory/file

In addition, Unix/Linux system file names are case-sensitive. Windows systems store the case of letters used in the file name,
but don't distinguish between their cases at all.

Python is smart enough to be able to convert slashes into backslashes each time it discovers that it's required by the OS.
name = "c:/dir/file" - will work with Windows, too.

Any program does not communicate with the files directly, but through some abstract entities that are named
like: handles or streams (the most-used terms)

To connect (bind) the stream with the file, it's necessary to perform an explicit operation.
The operation of connecting the stream with a file is called opening the file, while disconnecting this link is named closing the file.

the opening of the stream can fail, and it may happen due to several reasons: the most common is the lack of a file with a specified name.
It can also happen that the physical file exists, but the program is not allowed to open it.
There's also the risk that the program has opened too many streams, and the specific operating system may not
allow the simultaneous opening of more than n files

18. File streams
https://edube.org/learn/pe-2/processing-files-36

If the opening is successful, the program will be allowed to perform only the operations which are consistent with the declared open mode.
two basic operations performed on the stream:
read from the stream: the portions of the data are retrieved from the file and placed in a memory area managed by the program (e.g., a variable);
write to the stream: the portions of the data from the memory (e.g., a variable) are transferred to the file.

three basic modes used to open the stream:
read mode: a stream opened in this mode allows read operations only; trying to write to the stream will cause an exception UnsupportedOperation
write mode: a stream opened in this mode allows write operations only - attempting to read the stream will cause the exception UnsupportedOperation
update mode: a stream opened in this mode allows both writes and reads.

The stream behaves almost like a tape recorder.

19. File handles
every file is hidden behind an object of an adequate class.
An object of an adequate class is created when you open the file and annihilate it at the time of closing.

The operations you're allowed to use are imposed by the way in which you've opened the file.

objects:

IOBase
RawIOBase, BufferedIOBase, TextIOBase

Note: you never use constructors to bring these objects to life. The only way you obtain them is to invoke the function named open().
The function analyses the arguments you've provided, and automatically creates the required object.

If you want to get rid of the object, you invoke the method named close().

For our purposes, we'll concern ourselves only with streams represented by BufferIOBase and TextIOBase objects

all the streams are divided into text and binary streams.

The text streams ones are structured in lines; that is, they contain typographical characters
(letters, digits, punctuation, etc.) arranged in rows (lines). This file is written (or read) mostly character by character, or line by line.

The binary streams don't contain text but a sequence of bytes of any value.
for example, an executable program, an image, an audio or a video clip, a database file, etc.
the data is read/written byte by byte, or block by block

Unix - end of line: LF (ASCII code 10), in Python programs as \n
Windows - end of line: CR and LF (ASCII codes 13 and 10), in Python encoded as: \r\n

Solution: designed at the level of classes

opening of the stream:
stream = open(file, mode = 'r', encoding = None)

Let's analyze it:
-the name of the function (open) speaks for itself; if the opening is successful, the function returns a stream object;
otherwise, an exception is raised (e.g., FileNotFoundError if the file you're going to read doesn't exist);
-the first parameter of the function (file) specifies the name of the file to be associated with the stream;
-the second parameter (mode) specifies the open mode used for the stream;
-the third parameter (encoding) specifies the encoding type (e.g., UTF-8 when working with text files)

the opening must be the very first operation performed on the stream.
the mode and encoding arguments may be omitted - their default values are assumed then.

20. Opening the streams: modes
r open mode: read
the stream will be opened in read mode;
file associated with the stream must exist and has to be readable

w open mode: write
the stream will be opened in write mode;
file associated with the stream doesn't need to exist
if it doesn't exist it will be created; if it exists, it will be truncated to the length of zero (erased);

a open mode: append
the stream will be opened in append mode;
file associated with the stream doesn't need to exist;
if it doesn't exist, it will be created; if it exists the virtual recording head will be set at the end of the file

r+ open mode: read and update
the stream will be opened in read and update mode;
file associated with the stream must exist and has to be writeable
both read and write operations are allowed for the stream.

w+ open mode: write and update
stream will be opened in write and update mode;
file associated with the stream doesn't need to exist; if it doesn't exist, it will be created; the previous content of the file remains untouched;
both read and write operations are allowed for the stream.

If there is a letter b at the end of the mode string it means that the stream is to be opened in the binary mode.
If the mode string ends with a letter t the stream is opened in the text mode.
- Text mode is the default behaviour

Finally, the successful opening of the file will set the current file position (the virtual reading/writing head)
before the first byte of the file if the mode is not 'a' and after the last byte of file if the mode is set to 'a'.

You can also open a file for its exclusive creation. You can do this using the x open mode. If the file already exists,
the open() function will raise an exception.

https://edube.org/learn/pe-2/processing-files-41


21. Opening the stream for the first time

open for reading:
try:
    stream = open("C:\Users\User\Desktop\file.txt", "rt")
    # Processing goes here.
    stream.close()
except Exception as exc:
    print("Cannot open the file:", exc)


the open mode is defined as text to read (as text is the default setting, we can skip the t in mode string)
in case of success we get an object from the open() function and we assign it to the stream variable;
if open() fails, we handle the exception printing full error information (it's definitely good to know what exactly happened)

22. Pre-opened streams
When our program starts, the three streams are already opened and don't require any extra preparations

import sys
sys.stdin, sys.stdout, and sys.stderr

stdin
stdin (as standard input)
stdin stream is normally associated with the keyboard
the well-known input() function reads data from stdin by default.

sys.stdout
stdout (as standard output)
stdout stream is normally associated with the screen
the well-known print() function outputs the data to the stdout stream

sys.stderr
stderr (as standard error output)
stderr stream is normally associated with the screen, pre-open for writing, regarded as the primary place where
the running program should send information on the errors encountered during its work;
the separation of stdout (useful results produced by the program) from the stderr (error messages,
undeniably useful but does not provide results) gives the possibility of redirecting these two types of information to the different targets.

23. Closing streams
That action is performed by a method invoked from within open stream object: stream.close().
this doesn't include the stdin, stdout, and stderr streams which don't require it

the function expects exactly no arguments; the stream doesn't need to be opened
the function returns nothing but raises IOError exception in case of error;

Note:
This belief is only partly justified. If the stream was opened for writing and then a series of write operations were performed,
it may happen that the data sent to the stream has not been transferred to the physical device yet (due to mechanism called caching or buffering).
Since the closing of the stream forces the buffers to flush them, it may be that the flushes fail and therefore the close() fails too.


24. Diagnosing stream problems
The IOError object is equipped with a property named errno

try:
    # Some stream operations.
except IOError as exc:
    print(exc.errno)

The value of the errno attribute can be compared with one of the predefined symbolic constants defined in the errno module.

errno.EACCES â†’ Permission denied
The error occurs when you try, for example, to open a file with the read only attribute for writing.

errno.EBADF â†’ Bad file number
The error occurs when you try, for example, to operate with an unopened stream.

errno.EEXIST â†’ File exists
The error occurs when you try, for example, to rename a file with its previous name.

errno.EFBIG â†’ File too large
The error occurs when you try to create a file that is larger than the maximum allowed by the operating system.

errno.EISDIR â†’ Is a directory
The error occurs when you try to treat a directory name as the name of an ordinary file.

errno.EMFILE â†’ Too many open files
The error occurs when you try to simultaneously open more streams than acceptable for your operating system.

errno.ENOENT â†’ No such file or directory
The error occurs when you try to access a non-existent file/directory.

errno.ENOSPC â†’ No space left on device
The error occurs when there is no free space on the media.


there is a function that can dramatically simplify the error handling code.
Its name is strerror(), and it comes from the os module and expects just one argument - an error number.

from os import strerror

try:
    s = open("c:/users/user/Desktop/file.txt", "rt")
    # Actual processing goes here.
    s.close()
except Exception as exc:
    print("The file could not be opened:", strerror(exc.errno))


25. Key takeaways
1. A file needs to be open before it can be processed by a program, and it should be closed when the processing is finished.

Opening the file associates it with the stream, which is an abstract representation of the physical data stored on the media.
The way in which the stream is processed is called open mode. Three open modes exist:

read mode â€“ only read operations are allowed;
write mode â€“ only write operations are allowed;
update mode â€“ both writes and reads are allowed.

2. Depending on the physical file content, different Python classes can be used to process files. In general,
the BufferedIOBase is able to process any file, while TextIOBase is a specialized class dedicated to processing text files
(i.e. files containing human-visible texts divided into lines using new-line markers). Thus, the streams can be divided into binary and text ones.


3. The following open() function syntax is used to open a file:

open(file_name, mode=open_mode, encoding=text_encoding)

The invocation creates a stream object and associates it with the file named file_name, using the specified open_mode
and setting the specified text_encoding, or it raises an exception in the case of an error.


4. Three predefined streams are already open when the program starts:

sys.stdin â€“ standard input;
sys.stdout â€“ standard output;
sys.stderr â€“ standard error output.

4. The IOError exception object, created when any file operations fails (including open operations), contains a property named errno,
which contains the completion code of the failed action. Use this value to diagnose the problem.

Exercise 1

How do you encode an open() functionâ€™s mode argument value if you're going to create a new text file to only fill it with an article?

Check
"wt" or "w"

Exercise 2

What is the meaning of the value represented by errno.EACESS?

Check
Permission denied: you're not allowed to access the file's content.

Exercise 3

What is the expected output of the following code, assuming that the file named file does not exist?

import errno

try:
    stream = open("file", "rb")
    print("exists")
    stream.close()
except IOError as error:
    if error.errno == errno.ENOENT:
        print("absent")
    else:
        print("unknown")

Check
absent


26. Processing text files

If your text files contain some national characters not covered by the standard ASCII charset, you may need an additional step.
Your open() function invocation may require an argument denoting specific text encoding.
For example, if you're using a Unix/Linux OS configured to use UTF-8 as a system-wide setting, the open() function may look as follows:
stream = open('file.txt', 'rt', encoding='utf-8')

f = r'C:\Users\SosniT25951\PycharmProjects\PCAP\PE2 syllabus.txt'
stream = open(f, "rt", encoding = "utf-8")
print(stream)
>>>
<_io.TextIOWrapper name='C:\\Users\\SosniT25951\\PycharmProjects\\PCAP\\PE2 syllabus.txt' mode='rt' encoding='utf-8'>
stream.close()


27. read() function
If applied to a text file, the function is able to:
read a desired number of characters (including just one) from the file, and return them as a string;
read all the file contents, and return them as a string;
if there is nothing more to read (the virtual reading head reaches the end of the file), the function returns an empty string.

sample:
try to read the very first character from the file ch = s.read(1)
try to read the next character, and the process repeats. : ch = s.read(1) //  !!! virtual pointer moved!!!


If you're absolutely sure that the file's length is safe and you can read the whole file to the memory at once, you can do it
- the read() function, invoked without any arguments or with an argument that evaluates to None

content = s.read()

Remember - reading a terabyte-long file using this method may corrupt your OS. !!! - computer memory isn't stretchable. !!!

28. readline()
If you want to treat the file's contents as a set of lines, not a bunch of characters

The method tries to read a complete line of text from the file, and returns it as a string in the case of success.
Otherwise, it returns an empty string.

now you can also count lines easily, not only characters.

ccnt = lcnt = 0
s = open('text.txt', 'rt')
line = s.readline()
while line != '':
    lcnt += 1
    for ch in line:
        print(ch, end='')
        ccnt += 1
    line = s.readline()
s.close()


29. readlines().
Another method, which treats text file as a set of lines

The readlines() method, when invoked without arguments, tries to read all the file contents, and returns a list of strings, one element per file line.

But you can convince the readlines() method to read not more than a specified number of bytes at once
(the returning value remains the same - it's a list of a string).

s = open("text.txt")
print(s.readlines(20))
print(s.readlines(20))
print(s.readlines(20))
print(s.readlines(20))
s.close()

!!! The maximum accepted input buffer size is passed to the method as its argument. !!!

Note: when there is nothing to read from the file, the method returns an empty list

!!! To the extent of the buffer's size, you can expect that increasing it may improve input performance,
but there is no golden rule for it - try to find the optimal values yourself. !!!

We've decided to use a 15-byte-long buffer. Don't think it's a recommendation.

from os import strerror

try:
    ccnt = lcnt = 0
    s = open('text.txt', 'rt')
    lines = s.readlines(20)
    while len(lines) != 0:
        for line in lines:
            lcnt += 1
            for ch in line:
                print(ch, end='')
                ccnt += 1
        lines = s.readlines(10)
    s.close()
    print("\n\nCharacters in file:", ccnt)
    print("Lines in file:     ", lcnt)
except IOError as e:
    print("I/O error occurred:", strerror(e.errno))


30. object returned by the open() function

object returned by the open() function is an instance of the iterable class.
The iteration protocol defined for the file object is very simple -
its __next__ method just returns the next line read in from the file.

!!! Moreover, you can expect that the object automatically invokes close()
when any of the file reads reaches the end of the file. !!!

from os import strerror

try:
	ccnt = lcnt = 0
	for line in open('text.txt', 'rt'):
		lcnt += 1
		for ch in line:
			print(ch, end='')
			ccnt += 1
	print("\n\nCharacters in file:", ccnt)
	print("Lines in file:     ", lcnt)
except IOError as e:
	print("I/O error occurred: ", strerror(e.errno))


https://edube.org/learn/pe-2/working-with-real-files-48

31. Dealing with text files: write()
it expects just one argument - a string that will be transferred to an open file


32. What is a bytearray?
it's an array containing (amorphous) bytes.
Amorphous data is data which have no specific shape or form

data = bytearray(10)
Such an invocation creates a bytearray object able to store ten bytes.

Note: such a constructor fills the whole array with zeros.

they are mutable, they're a subject of the len() function, and you can access any of their elements using conventional indexing.

you mustn't set any byte array elements with a value which is not an integer -- TypeError exception
you're not allowed to assign a value that doesn't come from the range 0 to 255 inclusive -- ValueError exception

You can treat any byte array elements as integer values


33. how do we write a byte array to a binary file?

from os import strerror

data = bytearray(10)

for i in range(len(data)):
    data[i] = 10 + i

try:
    bf = open('file.bin', 'wb')
    bf.write(data)
    bf.close()
except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

# Your code that reads bytes from the stream should go here.


34. How do we read a binary file?
How to read bytes from a stream - 1

from os import strerror

data = bytearray(10)

try:
    bf = open('file.bin', 'rb')
    bf.readinto(data)
    bf.close()

    for b in data:
        print(hex(b), end=' ')
except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

if there are more data in the file than space in the argument, the read operation will stop before the end of the file;

How to read bytes from a stream -2
method named read()
Invoked without arguments, it tries to read all the contents of the file into the memory
it's immutable.

from os import strerror

try:
    bf = open('file.bin', 'rb')
    data = bytearray(bf.read())
    bf.close()

    for b in data:
        print(hex(b), end=' ')

except IOError as e:
    print("I/O error occurred:", strerror(e.errno))


!!! Be careful - don't use this kind of read if you're not sure that the file's contents will fit the available memory. !!!

If the read() method is invoked with an argument, it specifies the maximum number of bytes to be read.
The method tries to read the desired number of bytes from the file, and the length of the returned object
can be used to determine the number of bytes actually read.

try:
    bf = open('file.bin', 'rb')
    data = bytearray(bf.read(5))
    bf.close()

    for b in data:
        print(hex(b), end=' ')

except IOError as e:
    print("I/O error occurred:", strerror(e.errno))

Note: the first five bytes of the file have been read by the code - the next five are still waiting to be processed.

from os import strerror

srcname = input("Enter the source file name: ")
try:
    src = open(srcname, 'rb')
except IOError as e:
    print("Cannot open the source file: ", strerror(e.errno))
    exit(e.errno)

dstname = input("Enter the destination file name: ")
try:
    dst = open(dstname, 'wb')
except Exception as e:
    print("Cannot create the destination file: ", strerror(e.errno))
    src.close()
    exit(e.errno)

buffer = bytearray(65536)
total  = 0
try:
    readin = src.readinto(buffer)
    while readin > 0:
        written = dst.write(buffer[:readin])
        total += written
        readin = src.readinto(buffer)
except IOError as e:
    print("Cannot create the destination file: ", strerror(e.errno))
    exit(e.errno)

print(total,'byte(s) succesfully written')
src.close()
dst.close()

35. Key takeaways

1. To read a fileâ€™s contents, the following stream methods can be used:

read(number) â€“ reads the number characters/bytes from the file and returns them as a string; is able to read the whole file at once;
readline() â€“ reads a single line from the text file;
readlines(number) â€“ reads the number lines from the text file; is able to read all lines at once;
readinto(bytearray) â€“ reads the bytes from the file and fills the bytearray with them;

2. To write new content into a file, the following stream methods can be used:

write(string) â€“ writes a string to a text file;
write(bytearray) â€“ writes all the bytes of bytearray to a file;

3. The open() method returns an iterable object which can be used to iterate through all the file's lines inside a for loop. For example:

for line in open("file", "rt"):
    print(line, end='')


The code copies the file's contents to the console, line by line. Note: the stream closes itself automatically when it reaches the end of the file.


Exercise 1

What do we expect from the readlines() method when the stream is associated with an empty file?

Check
An empty list (a zero-length list).



Exercise 2

What is the following code intended to do?

for line in open("file", "rt"):
    for char in line:
        if char.lower() not in "aeiouy ":
            print(char, end='')


Check
It copies the file's contents to the console, ignoring all vowels.



Exercise 3

You're going to process a bitmap stored in a file named image.png, and you want to read its contents as a whole into a bytearray variable named image. Add a line to the following code to achieve this goal.

try:
    stream = open("image.png", "rb")
    # Insert a line here.
    stream.close()
except IOError:
    print("failed")
else:
    print("success")


Check
image = bytearray(stream.read())

https://edube.org/learn/pe-2/the-os-module-9

36. os module
lets you interact with the operating system using Python.
unctions of the os module, to perform operations on files and directories along with the corresponding commands.

Also, os module enables you to:

get information about the operating system;
manage processes;
operate on I/O streams using file descriptors.

37. Getting information about the operating system - uname
function called uname, which returns an object containing the following attributes:

systemname â€” stores the name of the operating system;
nodename â€” stores the machine name on the network;
release â€” stores the operating system release;
version â€” stores the operating system version;
machine â€” stores the hardware identifier, e.g., x86_64.

the uname function only works on some Unix systems. If you use Windows,
you can use the uname function in the platform module, which returns a similar result.

38. os.name
posix â€” you'll get this name if you use Unix;
nt â€” you'll get this name if you use Windows;
java â€” you'll get this name if your code is written in Jython.

39. Creating directories in Python - mkdir
mkdir function requires a path that can be relative or absolute

my_first_directory â€” this is a relative path which will create the my_first_directory directory in the current working directory;
./my_first_directory â€” this is a relative path that explicitly points to the current working directory. It has the same effect as the path above;
../my_first_directory â€” this is a relative path that will create the my_first_directory directory in the parent directory of the current working directory;
/python/my_first_directory â€” this is the absolute path that will create the my_first_directory directory, which in turn is in the python directory in the root directory.

import os

os.mkdir("my_first_directory")
print(os.listdir())

The mkdir function creates a directory in the specified path.
Note that running the program twice will raise a FileExistsError.

In addition to the path argument, the mkdir function can optionally take the mode argument, which specifies directory permissions.

To change the directory permissions, we recommend the chmod function

The listdir function returns a list containing the names of the files and directories that are in the path passed as an argument.

40. Recursive directory creation - makedirs
The makedirs function enables recursive directory creation, which means that all directories in the path will be created

import os

os.makedirs("my_first_directory/my_second_directory")
os.chdir("my_first_directory")
print(os.listdir())

>>>
['my_second_directory']

To move between directories, you can use a function called chdir
 which changes the current working directory to the specified path.
 it takes any relative or absolute path

41. Where am I now?
os.getcwd()
the getcwd function returns the absolute path to the directories.

42. Deleting directories in Python
To delete a single directory, you can use a function called rmdir,
which takes the path as its argument. Look at the code in the editor.

os.mkdir("my_first_directory")
print(os.listdir())
os.rmdir("my_first_directory")
print(os.listdir())

removedirs function - To remove a directory and its subdirectories
 which requires you to specify a path containing all directories that should be removed:

os.makedirs("my_first_directory/my_second_directory")
os.removedirs("my_first_directory/my_second_directory")
print(os.listdir())

!!! As with the rmdir function, if one of the directories doesn't exist or isn't empty, an exception will be raised. !!!

43. The system() function
All functions presented in this part of the course can be replaced by a function called system

import os

returned_value = os.system("mkdir my_first_directory")
print(returned_value)
>>> 0
my_first_directory directory has been created

44. Key takeaways
1. The uname function returns an object that contains information about the current operating system. The object has the following attributes:

systemname (stores the name of the operating system)
nodename (stores the machine name on the network)
release (stores the operating system release)
version (stores the operating system version)
machine (stores the hardware identifier, e.g. x86_64.)
2. The name attribute available in the os module allows you to distinguish the operating system. It returns one of the following three values:

posix (you'll get this name if you use Unix)
nt (you'll get this name if you use Windows)
java (you'll get this name if your code is written in something like Jython)
3. The mkdir function creates a directory in the path passed as its argument. The path can be either relative or absolute, e.g:

import os

os.mkdir("hello") # the relative path
os.mkdir("/home/python/hello") # the absolute path


Note: If the directory exists, a FileExistsError exception will be thrown. In addition to the mkdir function, the os module provides the makedirs function, which allows you to recursively create all directories in a path.

4. The result of the listdir() function is a list containing the names of the files and directories that are in the path passed as its argument.

It's important to remember that the listdir function omits the entries '.' and '..', which are displayed, for example, when using the ls -a command on Unix systems. If the path isn't passed, the result will be returned for the current working directory.

5. To move between directories, you can use a function called chdir(), which changes the current working directory to the specified path. As its argument, it takes any relative or absolute path.

If you want to find out what the current working directory is, you can use the getcwd() function, which returns the path to it.

6. To remove a directory, you can use the rmdir() function, but to remove a directory and its subdirectories, use the removedirs() function.

7. On both Unix and Windows, you can use the system function, which executes a command passed to it as a string, e.g.:

import os

returned_value = os.system("mkdir hello")


The system function on Windows returns the value returned by shell after running the command given, while on Unix it returns the exit status of the process.




Exercise 1

What is the output of the following snippet if you run it on Unix?

import os
print(os.name)


Check
posix


Exercise 2

What is the output of the following snippet?

import os

os.mkdir("hello")
print(os.listdir())


Check
['hello']

45. datetime module
https://edube.org/learn/pe-2/the-datetime-module-3

class called date. Objects of this class represent a date consisting of the year, month, and day.

The today method returns a date object representing the current local date.

from datetime import date

today = date.today()

print("Today:", today)
print("Year:", today.year)
print("Month:", today.month)
print("Day:", today.day)

Note that the date object has three attributes: year, month, and day.
!!! Note that the date object has three attributes: year, month, and day. !!!

To create a date object, you must pass the year, month, and day parameters as follows:
from datetime import date

my_date = date(2019, 11, 4)
print(my_date)

year - The year parameter must be greater than or equal to 1 (MINYEAR constant) and less than or equal to 9999 (MAXYEAR constant).
month - The month parameter must be greater than or equal to 1 and less than or equal to 12.
day - The day parameter must be greater than or equal to 1 and less than or equal to the last day of the given month and year.

46. Creating a date object from a timestamp
In Unix, the timestamp expresses the number of seconds since January 1, 1970, 00:00:00 (UTC).
This date is called the Unix epoch, because this is when the counting of time began on Unix systems.

To create a date object from a timestamp, we must pass a Unix timestamp to the fromtimestamp method.

from datetime import date
import time

timestamp = time.time()
print("Timestamp:", timestamp)

d = date.fromtimestamp(timestamp)
print("Date:", d)
>>>
Timestamp: 1648365185.8547485
Date: 2022-03-27

function called time() that returns the number of seconds from January 1, 1970 to the current moment in the form of a float number.


47. Creating a date object using the ISO format
fromisoformat method, which takes a date in the YYYY-MM-DD format

from datetime import date

d = date.fromisoformat('2019-11-04')
print(d)
>>> 2019-11-04

When substituting the date, be sure to add 0 before a month or a day that is expressed by a number less than 10. -> ValueError
fromisoformat method has been available in Python since version 3.7.


48. The replace() method
You canâ€™t do this with the year, month, and day attributes because they're read-only.

The year, month, and day parameters are optional. You can pass only one parameter to the replace method,

The replace method returns a changed date object, so you must remember to assign it to some variable.

from datetime import date

d = date(1991, 2, 5)
print(d)

d = d.replace(year=1992, month=1, day=16)
print(d)
>>> 1992-01-16


49. What day of the week is it?
weekday returns the day of the week as an integer, where 0 is Monday and 6 is Sunday

from datetime import date

d = date(2019, 11, 4)
print(d.weekday())
>>> 0

Note: isoweekday, which also returns the day of the week as an integer, but 1 is Monday, and 7 is Sunday

50. Creating time objects
time - class that allows you to present time

time(hour, minute, second, microsecond, tzinfo, fold)

hour - The hour parameter must be greater than or equal to 0 and less than 23.
minute - The minute parameter must be greater than or equal to 0 and less than 59.
second - The second parameter must be greater than or equal to 0 and less than 59.
microsecond - The microsecond parameter must be greater than or equal to 0 and less than 1000000.
tzinfo - The tzinfo parameter must be a tzinfo subclass object or None (default).
fold - The fold parameter must be 0 or 1 (default 0).

The tzinfo parameter is associated with time zones

from datetime import time

t = time(14, 59, 20, 1)

print("Time:", t)
print("Hour:", t.hour)
print("Minute:", t.minute)
print("Second:", t.second)
print("Microsecond:", t.microsecond)

>>>
Time: 14:59:20.000001
Hour: 14
Minute: 59
Second: 20
Microsecond: 1


51. The time module
In addition to the time class, the Python standard library offers a module called time
, which provides a time-related function.

sleep function - which suspends program execution for the given number of seconds.

import time
time.sleep(5) // in seconds

!!!Note that the sleep function accepts only an integer or a floating point number. !!!

52. The ctime() function
time module provides a function called ctime, which converts the time in seconds since January 1, 1970 (Unix epoch) to a string.

import time

timestamp = 1572879180
print(time.ctime(timestamp))
>>> Mon Nov  4 14:53:00 2019

The ctime function returns a string for the passed timestamp.

It's also possible to call the ctime function without specifying the time in seconds. In this case, the current time will be returned:
import time
print(time.ctime())


53. The gmtime() and localtime() functions
The example shows two functions that convert the elapsed time from the Unix epoch to the struct_time object.

import time

timestamp = 1572879180
print(time.gmtime(timestamp))
print(time.gmtime(timestamp).tm_year)
print(time.localtime(timestamp))

>>> time.struct_time(tm_year=2019, tm_mon=11, tm_mday=4, tm_hour=14, ...
>>> 2019
>>> time.struct_time(tm_year=2019, tm_mon=11, tm_mday=4, tm_hour=14, ...

time.struct_time:
    tm_year   # specifies the year
    tm_mon    # specifies the month (value from 1 to 12)
    tm_mday   # specifies the day of the month (value from 1 to 31)
    tm_hour   # specifies the hour (value from 0 to 23)
    tm_min    # specifies the minute (value from 0 to 59)
    tm_sec    # specifies the second (value from 0 to 61 )
    tm_wday   # specifies the weekday (value from 0 to 6)
    tm_yday   # specifies the year day (value from 1 to 366)
    tm_isdst  # specifies whether daylight saving time applies (1 â€“ yes, 0 â€“ no, -1 â€“ it isn't known)
    tm_zone   # specifies the timezone name (value in an abbreviated form)
    tm_gmtoff # specifies the offset east of UTC (value in seconds)


The struct_time class also allows access to values using indexes. Index 0 returns the value in tm_year, while 8 returns the value in tm_isdst.
The exceptions are tm_zone and tm_gmoff, which cannot be accessed using indexes.

54. The asctime() and mktime() functions
The time module has functions that expect a struct_time object or
a tuple that stores values according to the indexes presented when discussing the struct_time class.

import time

timestamp = 1572879180
st = time.gmtime(timestamp)

print(time.asctime(st))
print(time.mktime((2019, 11, 4, 14, 53, 0, 0, 308, 0)))

>>>
Mon Nov  4 14:53:00 2019
1572879180.0

asctime, converts a struct_time object or a tuple to a string.
If you don't provide an argument to the asctime function, the time returned by the localtime function will be used.

mktime converts a struct_time object or a tuple that expresses the local time to the number of seconds since the Unix epoch.

2019 => tm_year
11 => tm_mon
4 => tm_mday
14 => tm_hour
53 => tm_min
0 => tm_sec
0 => tm_wday
308 => tm_yday
0 => tm_isdst


55. Creating datetime objects
https://edube.org/learn/pe-2/the-datetime-and-time-modules-continued-10

The class that combines date and time is called datetime.

datetime(year, month, day, hour, minute, second, microsecond, tzinfo, fold)

The tzinfo parameter must be a tzinfo subclass object or None (default).
The fold parameter must be 0 or 1 (default 0).

from datetime import datetime

dt = datetime(2019, 11, 4, 14, 53)

print("Datetime:", dt)
print("Date:", dt.date())
print("Time:", dt.time())

>>>
Datetime: 2019-11-04 14:53:00
Date: 2019-11-04
Time: 14:53:00

All parameters passed to the constructor go to read-only class attributes.


56. Methods that return the current date and time
The datetime class has several methods that return the current date and time.
today() â€” returns the current local date and time with the tzinfo attribute set to None;
now() â€” returns the current local date and time the same as the today method, unless we pass the optional argument tz to it
utcnow() â€” returns the current UTC date and time with the tzinfo attribute set to None

from datetime import datetime

print("today:", datetime.today())
print("now:", datetime.now())
print("utcnow:", datetime.utcnow())
>>>
2022-03-28 17:48:10.216604 // the result of all the three methods is the same

57. Getting a timestamp
The timestamp method returns a float value expressing the number of seconds elapsed between the date and
time indicated by the datetime object and January 1, 1970, 00:00:00 (UTC).

from datetime import datetime

dt = datetime(2020, 10, 4, 14, 55)
print("Timestamp:", dt.timestamp())
>>>
Timestamp: 1601823300.0


58. Date and time formatting (part 1)
All datetime module classes presented so far have a method called strftime.
This is a very important method, because it allows us to return the date and time in the format we specify.

The strftime method takes only one argument in the form of a string specifying the format that can consist of directives.
A directive is a string consisting of the character % (percent) and a lowercase or uppercase letter

from datetime import date

d = date(2020, 1, 4)
print(d.strftime('%Y/%m/%d'))
>>>
2020/01/04

%Y â€“ returns the year with the century as a decimal number. In our example, this is 2020.
%m â€“ returns the month as a zero-padded decimal number. In our example, it's 01.
%d â€“ returns the day as a zero-padded decimal number. In our example, it's 04.

directives at:
https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes

58. Date and time formatting (part 2)
In general, you've got a lot of freedom in creating formats, but you must remember to use the directives properly.

from datetime import time
from datetime import datetime

t = time(14, 53)
print(t.strftime("%H:%M:%S"))

dt = datetime(2020, 11, 4, 14, 53)
print(dt.strftime("%y/%B/%d %H:%M:%S"))
>>>
14:53:00
20/November/04 14:53:00


59. The strftime() function in the time module
https://edube.org/learn/pe-2/the-datetime-and-time-modules-continued-15

slightly different from the strftime methods in the classes provided by the datetime module because, in addition to the format argument,
it can also take (optionally) a tuple or struct_time object.

If you don't pass a tuple or struct_time object, the formatting will be done using the current local time.

import time

timestamp = 1572879180
st = time.gmtime(timestamp)

print(type(st), st)
print(time.strftime("%Y/%m/%d %H:%M:%S", st))
print(time.strftime("%Y/%m/%d %H:%M:%S"))
>>>
<class 'time.struct_time'> time.struct_time(tm_year=2019, tm_mon=11, tm_mday=4, tm_hour=14, tm_min=53, tm_sec=0, tm_wday=0, tm_yday=308, tm_isdst=0)
2019/11/04 14:53:00
2022/03/30 18:11:17


60. The strptime() method
it creates a datetime object from a string representing a date and time.

if the format you specify doesn't match the date and time in the string, it'll raise a ValueError.

from datetime import datetime
print(datetime.strptime("2019/11/04 14:53:00", "%Y/%m/%d %H:%M:%S"))

Note: In the time module, you can find a function called strptime, which parses a string representing a time to a struct_time object.
Its use is analogous to the strptime method in the datetime class:

import time
print(time.strptime("2019/11/04 14:53:00", "%Y/%m/%d %H:%M:%S"))
>>>
time.struct_time(tm_year=2019, tm_mon=11, tm_mday=4, tm_hour=14, tm_min=53, tm_sec=0, tm_wday=0, tm_yday=308, tm_isdst=-1)
<class 'datetime.datetime'>

61. Date and time operations
https://edube.org/learn/pe-2/the-datetime-and-time-modules-continued-17

timedelta in the datetime to do calculations on dates

To create a timedelta object, just do subtraction on the date or datetime objects

from datetime import date
from datetime import datetime

d1 = date(2020, 11, 4)
d2 = date(2019, 11, 4)

print(d1 - d2)

dt1 = datetime(2020, 11, 4, 0, 0, 0)
dt2 = datetime(2019, 11, 4, 14, 53, 0)

print(dt1 - dt2)

>>>
366 days, 0:00:00
365 days, 9:07:00

62. Creating timedelta objects
Arguments accepted by the class constructor, which are: days, seconds, microseconds, milliseconds, minutes, hours, and weeks.
Each of them is optional and defaults to 0.
The arguments should be integers or floating point numbers, and can be either positive or negative.

from datetime import timedelta

delta = timedelta(weeks=2, days=2, hours=3)
print(delta)
>>>
16 days, 3:00:00

!!! timedelta object only stores days, seconds, and microseconds internally. !!!

from datetime import timedelta

delta = timedelta(weeks=2, days=2, hours=3)
print("Days:", delta.days)
print("Seconds:", delta.seconds)
print("Microseconds:", delta.microseconds)
>>>
Days: 16
Seconds: 10800
Microseconds: 0

!!! Weeks are converted to days, hours and minutes to seconds, and milliseconds to microseconds. !!!

from datetime import timedelta
from datetime import date
from datetime import datetime

delta = timedelta(weeks=2, days=2, hours=2)
print(delta)

delta2 = delta * 2
print(delta2)

d = date(2019, 10, 4) + delta2
print(d)

dt = datetime(2019, 10, 4, 14, 53) + delta2
print(dt)

>>>
16 days, 2:00:00
32 days, 4:00:00
2019-11-05
2019-11-05 18:53:00


63. Key takeaways
Key takeaways
1. To create a date object, you must pass the year, month, and day arguments as follows:

from datetime import date

my_date = date(2020, 9, 29)
print("Year:", my_date.year) # Year: 2020
print("Month:", my_date.month) # Month: 9
print("Day:", my_date.day) # Day: 29


The date object has three (read-only) attributes: year, month, and day.


2. The today method returns a date object representing the current local date:

from datetime import date
print("Today:", date.today()) # Displays: Today: 2020-09-29



3. In Unix, the timestamp expresses the number of seconds since January 1, 1970, 00:00:00 (UTC).
This date is called the "Unix epoch", because it began the counting of time on Unix systems.
The timestamp is actually the difference between a particular date (including time) and January 1, 1970, 00:00:00 (UTC),
expressed in seconds. To create a date object from a timestamp, we must pass a Unix timestamp to the fromtimestamp method:

from datetime import date
import time

timestamp = time.time()
d = date.fromtimestamp(timestamp)


Note: The time function returns the number of seconds from January 1, 1970 to the current moment in the form of a float number.


4. The constructor of the time class accepts six arguments (hour, minute, second, microsecond, tzinfo, and fold). Each of these arguments is optional.

from datetime import time

t = time(13, 22, 20)

print("Hour:", t.hour) # Hour: 13
print("Minute:", t.minute) # Minute: 22
print("Second:", t.second) # Second: 20



5. The time module contains the sleep function, which suspends program execution for a given number of seconds, e.g.:

import time

time.sleep(10)
print("Hello world!") # This text will be displayed after 10 seconds.



6. In the datetime module, date and time can be represented either as separate objects, or as one object. The class that
combines date and time is called datetime. All arguments passed to the constructor go to read-only class attributes.
They are year, month, day, hour, minute, second, microsecond, tzinfo, and fold:

from datetime import datetime

dt = datetime(2020, 9, 29, 13, 51)
print("Datetime:", dt) # Displays: Datetime: 2020-09-29 13:51:00



7. The strftime method takes only one argument in the form of a string specifying a format that can consist of directives.
A directive is a string consisting of the character % (percent) and a lowercase or uppercase letter. Below are some useful directives:

%Y â€“ returns the year with the century as a decimal number;
%m â€“ returns the month as a zero-padded decimal number;
%d â€“ returns the day as a zero-padded decimal number;
%H â€“ returns the hour as a zero-padded decimal number;
%M â€“ returns the minute as a zero-padded decimal number;
%S â€“ returns the second as a zero-padded decimal number.
Example:

from datetime import date

d = date(2020, 9, 29)
print(d.strftime('%Y/%m/%d')) # Displays: 2020/09/29



8. It's possible to perform calculations on date and datetime objects, e.g.:

from datetime import date

d1 = date(2020, 11, 4)
d2 = date(2019, 11, 4)

d = d1 - d2
print(d) # Displays: 366 days, 0:00:00.
print(d * 2) # Displays: 732 days, 0:00:00.


The result of the subtraction is returned as a timedelta object that expresses the difference in days between the two
dates in the example above.

Note that the difference in hours, minutes, and seconds is also displayed. The timedelta object can be used for further
calculations (e.g. you can multiply it by 2).




Exercise 1

What is the output of the following snippet?

from datetime import time

t = time(14, 39)
print(t.strftime("%H:%M:%S"))


Check
14:39:00


Exercise 2

What is the output of the following snippet?

from datetime import datetime

dt1 = datetime(2020, 9, 29, 14, 41, 0)
dt2 = datetime(2020, 9, 28, 14, 41, 0)

print(dt1 - dt2)


Check
1 day, 0:00:00


64. Introduction to the calendar module
days of the week are displayed from Monday to Sunday, and each day of the week has its representation in the form of an integer:

Day of the week	Integer value	Constant
Monday	0	calendar.MONDAY
Tuesday	1	calendar.TUESDAY
Wednesday	2	calendar.WEDNESDAY
Thursday	3	calendar.THURSDAY
Friday	4	calendar.FRIDAY
Saturday	5	calendar.SATURDAY
Sunday	6	calendar.SUNDAY

For months, integer values are indexed from 1, i.e., January is represented by 1, and December by 12.
Unfortunately, there aren't constants that express the months.

import calendar
print(calendar.calendar(2020))
>>>
display the calendar for the whole year.

to change the default calendar formatting, you can use the following parameters:
w â€“ date column width (default 2)
l â€“ number of lines per week (default 1)
c â€“ number of spaces between month columns (default 6)
m â€“ number of columns (default 3)

The calendar function requires you to specify the year, while the other parameters responsible for formatting are optional.

prcal doesn't require the use of the print function to display the calendar:
import calendar
calendar.prcal(2020)

Calendar for a specific month
import calendar
print(calendar.month(2020, 11))

You can also use the prmonth function

65. The setfirstweekday() function
changes display of the first day of the week

import calendar

calendar.setfirstweekday(calendar.SUNDAY)
calendar.prmonth(2020, 12)


66. The weekday() function
returns the day of the week as an integer value for the given year, month, and day

import calendar
print(calendar.weekday(2020, 12, 24))
>>>
3: which means that December 24, 2020 is a Thursday.


67. The weekheader() function
you can get short weekday names using the weekheader method.

import calendar
print(calendar.weekheader(2))
>>>
Mo Tu We Th Fr Sa Su

Note: If you change the first day of the week, e.g., using the setfirstweekday function, it'll affect the result of the weekheader


68. How do we check if a year is a leap year?
import calendar

print(calendar.isleap(2020))
print(calendar.leapdays(2010, 2021))  # Up to but not including 2021, returns the number of leap years in the given range of years.
>>>
True
3


68. Classes for creating calendars
calendar.Calendar â€“ provides methods to prepare calendar data for formatting;
calendar.TextCalendar â€“ is used to create regular text calendars;
calendar.HTMLCalendar â€“ is used to create HTML calendars;
calendar.LocalTextCalendar â€“ is a subclass of the calendar.TextCalendar class.
    The constructor of this class takes the locale parameter, which is used to return the appropriate months and weekday names.
calendar.LocalHTMLCalendar â€“ is a subclass of the calendar.HTMLCalendar class.
    The constructor of this class takes the locale parameter, which is used to return the appropriate months and weekday names


69. Creating a Calendar object
https://edube.org/learn/pe-2/the-calendar-module-23



















