1. Generators
a piece of specialized code able to produce a series of values, and to control the iteration process
very often called iterators

range() function is a generator, which is (in fact, again) an iterator.

function returns one value, generator returns a series of values and is (implicitly) invoked more than once.


2. Iterator protocol.
iterator protocol is a way in which an object should behave to conform to the rules
imposed by the context of the for and in statements.

iterator must provide two methods:
__iter__() which should return the object itself and which is invoked once (it's needed for Python to successfully start the iteration)
__next__() which is intended to return the next value (first, second, and so on) of the desired series
    if there are no more values to provide, the method should raise the StopIteration exception.

The object of the class may be used as an iterator when (and only when) it positively answers to the __iter__ invocation

sample iterator:
class Fib:
    def __init__(self, nn):
        self.__n = nn
        self.__i = 0
        self.__p1 = self.__p2 = 1

    def __iter__(self):
        print("Fib iter")
        return self

    def __next__(self):
        self.__i += 1
        if self.__i > self.__n:
            raise StopIteration
        if self.__i in [1, 2]:
            return 1
        ret = self.__p1 + self.__p2
        self.__p1, self.__p2 = self.__p2, ret
        return ret

class Class:
    def __init__(self, n):
        self.__iter = Fib(n)

    def __iter__(self):
        print("Class iter")
        return self.__iter;


object = Class(8)

for i in object:
    print(i)


3. The yield statement
The main discomfort it brings is the need to save the state of the iteration between subsequent __iter__ invocations.
This makes the code larger and less comprehensible.

def fun(n):
    for i in range(n):
        return i

such a function is not able to save and restore its state between subsequent invocations.

def fun(n):
    for i in range(n):
        yield i

This little amendment turns the function into a generator

This provides the value of the expression specified after the yield keyword, just like return, but doesn't lose the state of the function.
All the variables' values are frozen, and wait for the next invocation, when the execution is resumed (not taken from scratch,
like after return).

There is one important limitation:
such a function should not be invoked explicitly as - in fact - it isn't a function anymore; it's a generator object.
The invocation will return the object's identifier


4. How to build a generator

def fun(n):
    for i in range(n):
        yield i


for v in fun(5):
    print(v, end='')

>>>
0 1 2 3 4


5. Generators may also be used within list comprehensions
6. The list() function can transform a series of subsequent generator invocations into a real list
7. The context created by the 'in' operator allows you to use a generator

8. Fibonacci generator

def fibonacci(n):
    p = pp = 1
    for i in range(n):
        if i in [0, 1]:
            yield 1
        else:
            n = p + pp
            pp, p = p, n
            yield n

fibs = list(fibonacci(10))
print(fibs)


9. expression_one if condition else expression_two
the_list = []

for x in range(10):
    the_list.append(1 if x % 2 == 0 else 0)

it is not a conditional instruction. Moreover, it's not an instruction at all. It's an operator.


10. List comprehensions vs. generators
Just one change can turn any list comprehension into a generator. - It's the parentheses.

the_list = [1 if x % 2 == 0 else 0 for x in range(10)]
the_generator = (1 if x % 2 == 0 else 0 for x in range(10))

The code, however, when run, produces two identical lines:

But:
len(the_list) will evaluate to 10. len(the_generator) will raise an exception: TypeError: object of type 'generator' has no len()

Of course, saving either the list or the generator is not necessary - you can create them exactly in the place where you need them

!!!
Note: the same appearance of the output doesn't mean that both loops work in the same way.
In the first loop, the list is created (and iterated through) as a whole - it actually exists when the loop is being executed.
In the second loop, there is no list at all - there are only subsequent values produced by the generator, one by one.
!!!

https://edube.org/learn/pe-2/generators-and-closures-50


10. The lambda function
A lambda function is a function without a name (you can also call it an anonymous function).
Programmers use the lambda function to simplify the code, to make it clearer and easier to understand

lambda parameters: expression

two = lambda: 2
sqr = lambda x: x * x
pwr = lambda x, y: x ** y

for a in range(-2, 3):
    print(sqr(a), end=" ")
    print(pwr(a, two()))


the first lambda is an anonymous parameterless function that always returns 2
As we've assigned it to a variable named two, we can say that the function is not anonymous anymore, and we can use the name to invoke it.

the second one is a one-parameter anonymous function

the third lambda takes two parameters and returns the value of the first one raised to the power of the second one.


11. How to use lambdas and what for?
you can use them in their pure form - as anonymous parts of code intended to evaluate a result.

12. Lambdas and the map() function
map(func, *iterables) --> map object

the second map() argument may be any entity that can be iterated (e.g., a tuple, or just a generator)

map() can accept more than two arguments:
list(map(lambda x, y: x + y, [1,2,3], [3,4,5]))
>>> [4, 6, 8]

The map() function applies the function passed by its first argument to all its second argument's elements,
and returns an iterator delivering all subsequent function results.

You can use the resulting iterator in a loop, or convert it into a list using the list() function.

for x in map(lambda x: x * x, list_2):
    print(x, end=' ')


13. Lambdas and the filter() function
filter(function or None, iterable) --> filter object

Return an iterator yielding those items of iterable for which function(item)
is true. If function is None, return the items that are true.

it filters its second argument while being guided by directions flowing from the function specified as the first argument

The elements which return True from the function pass the filter - the others are rejected.

filtered = list(filter(lambda x: x > 0 and x % 2 == 0, data))


list(filter(None, [1,2,3,4,0]))
>>> [1, 2, 3, 4]


14. A brief look at closures
closure is a technique which allows the storing of values in spite of the fact
that the context in which they have been created does not exist anymore

def outer(par):
    loc = par

    def inner():
        return loc
    return inner

var = 1
fun = outer(var)
print(fun())

>>> 1

The function returned during the outer() invocation is a closure.

15. A brief look at closures: continued
A closure has to be invoked in exactly the same way in which it has been declared.
e.g.: the inner() function is parameterless, so we have to invoke it without arguments.

it is fully possible to declare a closure equipped with an arbitrary number of parameters,

you can create as many closures as you want using one and the same piece of code.


16. Key takeaways

1. An iterator is an object of a class providing at least two methods (not counting the constructor!):

__iter__() is invoked once when the iterator is created and returns the iterator's object itself;
__next__() is invoked to provide the next iteration's value and raises the StopIteration exception when the iteration comes to and end.

2. The yield statement can be used only inside functions. The yield statement suspends function execution and causes the
function to return the yield's argument as a result. Such a function cannot be invoked in a regular way â€“
its only purpose is to be used as a generator (i.e. in a context that requires a series of values, like a for loop.)


3. A conditional expression is an expression built using the if-else operator. For example:

print(True if 0 >=0 else False)


outputs True.


4. A list comprehension becomes a generator when used inside parentheses (used inside brackets, it produces a regular list). For example:

for x in (el * 2 for el in range(5)):
    print(x)

outputs 02468.


4. A lambda function is a tool for creating anonymous functions. For example:

def foo(x,f):
    return f(x)

print(foo(9, lambda x: x ** 0.5))


outputs 3.0.


5. The map(fun, list) function creates a copy of a list argument, and applies the fun function to all of its elements,
returning a generator that provides the new list content element by element. For example:

short_list = ['mython', 'python', 'fell', 'on', 'the', 'floor']
new_list = list(map(lambda s: s.title(), short_list))
print(new_list)


outputs ['Mython', 'Python', 'Fell', 'On', 'The', 'Floor'].


6. The filter(fun, list) function creates a copy of those list elements, which cause the fun function to return True.
The function's result is a generator providing the new list content element by element. For example:

short_list = [1, "Python", -1, "Monty"]
new_list = list(filter(lambda s: isinstance(s, str), short_list))
print(new_list)


outputs ['Python', 'Monty'].


7. A closure is a technique which allows the storing of values in spite of the fact that the context in which they have
been created does not exist anymore. For example:

def tag(tg):
    tg2 = tg
    tg2 = tg[0] + '/' + tg[1:]

    def inner(str):
        return tg + str + tg2
    return inner


b_tag = tag('<b>')
print(b_tag('Monty Python'))


outputs <b>Monty Python</b>



Exercise 1

What is the expected output of the following code?

class Vowels:
    def __init__(self):
        self.vow = "aeiouy "  # Yes, we know that y is not always considered a vowel.
        self.pos = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.pos == len(self.vow):
            raise StopIteration
        self.pos += 1
        return self.vow[self.pos - 1]


vowels = Vowels()
for v in vowels:
    print(v, end=' ')


Check
a e i o u y



Exercise 2

Write a lambda function, setting the least significant bit of its integer argument, and apply it to the map() function
to produce the string 1 3 3 5 on the console.

any_list = [1, 2, 3, 4]
even_list = # Complete the line here.
print(even_list)


Check
list(map(lambda n: n | 1, any_list))



Exercise 3

What is the expected output of the following code?

def replace_spaces(replacement='*'):
    def new_replacement(text):
        return text.replace(' ', replacement)
    return new_replacement


stars = replace_spaces()
print(stars("And Now for Something Completely Different"))


Check
And*Now*for*Something*Completely*Different

Note

PEP 8, the Style Guide for Python Code, recommends that lambdas should not be assigned to variables, but rather they should be defined as functions.

This means that it is better to use a def statement, and avoid using an assignment statement that binds a lambda expression to an identifer. For example:

# Recommended:
def f(x): return 3*x


# Not recommended:
f = lambda x: 3*x


Binding lambdas to identifiers generally duplicates the functionality of the def statement. Using def statements,
on the other hand, generates more lines of code.

It is important to understand that reality often likes to draw its own scenarios, which do not necessarily follow the
conventions or formal recommendations. Whether you decide to follow them or not will depend on many things: your preferences,
other conventions adopted, company internal guidelines, compatibility with existing code, etc. Be aware of this.


17. Accessing files from Python code
If we want to implement a simple database, the only way to store the information between program runs is to save it
into a file (or files if your database is more complex).

Windows: C:\directory\file
Unix: /directory/file

In addition, Unix/Linux system file names are case-sensitive. Windows systems store the case of letters used in the file name,
but don't distinguish between their cases at all.

Python is smart enough to be able to convert slashes into backslashes each time it discovers that it's required by the OS.
name = "c:/dir/file" - will work with Windows, too.

Any program does not communicate with the files directly, but through some abstract entities that are named
like: handles or streams (the most-used terms)

To connect (bind) the stream with the file, it's necessary to perform an explicit operation.
The operation of connecting the stream with a file is called opening the file, while disconnecting this link is named closing the file.

the opening of the stream can fail, and it may happen due to several reasons: the most common is the lack of a file with a specified name.
It can also happen that the physical file exists, but the program is not allowed to open it.
There's also the risk that the program has opened too many streams, and the specific operating system may not
allow the simultaneous opening of more than n files

18. File streams
https://edube.org/learn/pe-2/processing-files-36




