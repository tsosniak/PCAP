1. What is a module?
A file containing Python definitions and statements, which can be later imported and used when necessary
a module is identified by its name.

Computer code has a tendency to grow
Growing code is in fact a growing problem. A larger code always means tougher maintenance.

Searching for bugs is always easier where the code is smaller

From decomposition perspective:
divide all the tasks among the developers;
join all the created parts into one working whole.

For example, a certain project can be divided into two main parts:
the user interface (the part that communicates with the user using widgets and a graphical screen)
the logic (the part processing data and producing results)

Each of these parts can be (most likely) divided into smaller ones, and so on. Such a process is often called decomposition.

Modules are the answer.

you are the module's user;
or: you are the module's supplier.


All these modules (provided at start by Python), along with the built-in functions, form the Python standard library

Each module consists of entities (like a book consists of chapters). These entities can be functions, variables, constants, classes, and objects.


2. Importing a module
The simplest way to import a particular module is to use the import instruction as follows:
import math

The clause contains:

the import keyword;
the name of the module which is subject to import.

The instruction may be located anywhere in your code, but it must be placed before the first use of any of the module's entities.

import math
import sys

or

import math, sys

The modules' list may be arbitrarily long.

3. Namespace
A namespace is a space (understood in a non-physical context) in which some names exist and the names don't conflict with each other
(i.e., there are not two different objects of the same name).

Inside a certain namespace, each name must remain unique.

If the module of a specified name exists and is accessible (a module is in fact a Python source file), Python imports its contents,
i.e., all the names defined in the module become known, but they don't enter your code's namespace.

put:

the name of the module (e.g., math)
a dot (i.e., .)
the name of the entity (e.g., pi)

Such a form clearly indicates the namespace in which the name exists.

import math
print(math.sin(math.pi/2))

Now we're going to show you how the two namespaces (yours and the module's one) can coexist.

import math


def sin(x):
    if 2 * x == pi:
        return 0.99999999
    else:
        return None


pi = 3.14

print(sin(pi/2))
print(math.sin(math.pi/2))


from math import pi

The instruction consists of the following elements:

the from keyword;
the name of the module to be (selectively) imported;
the import keyword;
the name or list of names of the entity/entities which are being imported into the namespace.

Note: no other entities are imported. Moreover, you cannot import additional entities using a qualification

!!!the imported symbols may supersede their previous definitions within the namespace!!!


Importing a module: *
from module import *
Such an instruction imports all entities from the indicated module.
Is it unsafe? Yes, it is - you may not be able to avoid name conflicts

Importing a module: the as keyword (aliasing)
Aliasing causes the module to be identified under a different name than the original. This may shorten the qualified names, too
import module as alias
e.g. import math as m
print(m.sin(m.pi/2))

!!!Note: after successful execution of an aliased import, the original module name becomes inaccessible and must not be used.!!!

The phrase name as alias can be repeated
from module import n as a, m as b, o as c

4. Key takeaways

1. If you want to import a module as a whole, you can do it using the import module_name statement. You are allowed to import more than one module at once using a comma-separated list. For example:

import mod1
import mod2, mod3, mod4


although the latter form is not recommended due to stylistic reasons, and it's better and prettier to express the same intention in more a verbose and explicit form, such as:

import mod2
import mod3
import mod4


2. If a module is imported in the above manner and you want to access any of its entities, you need to prefix the entity's name using dot notation. For example:

import my_module

result = my_module.my_function(my_module.my_data)


The snippet makes use of two entities coming from the my_module module: a function named my_function() and a variable named my_data. Both names must be prefixed by my_module. None of the imported entity names conflicts with the identical names existing in your code's namespace.


3. You are allowed not only to import a module as a whole, but to import only individual entities from it. In this case, the imported entities must not be prefixed when used. For example:

from module import my_function, my_data

result = my_function(my_data)


The above way - despite its attractiveness - is not recommended because of the danger of causing conflicts with names derived from importing the code's namespace.


4. The most general form of the above statement allows you to import all entities offered by a module:

from my_module import *

result = my_function(my_data)


Note: this import's variant is not recommended due to the same reasons as previously (the threat of a naming conflict is even more dangerous here).

5. You can change the name of the imported entity "on the fly" by using the as phrase of the import. For example:

from module import my_function as fun, my_data as dat

result = fun(dat)



Exercise 1

You want to invoke the function make_money() contained in the module named mint. Your code begins with the following line:

import mint


What is the proper form of the function's invocation?

Check
mint.make_money()



Exercise 2

You want to invoke the function make_money() contained in the module named mint. Your code begins with the following line:

from mint import make_money


What is the proper form of the function's invocation?

Check
make_money()



Exercise 3

You've written a function named make_money on your own. You need to import a function of the same name from the mint module and don't want to rename any of your previously defined names. Which variant of the import statement may help you with the issue?

Check
# sample solution
from mint import make_money as make_more_money



Exercise 4

What form of the make_money function invocation is valid if your code starts with the following line?

from mint import *


Check
make_money()


https://edube.org/learn/pe-2/section-summary-88


5. Working with standard modules
dir() function
it is able to reveal all the names provided through a particular module
There is one condition: the module has to have been previously imported as a whole (i.e., using the import module instruction - from module is not enough).

The function returns an alphabetically sorted list containing all entities' names available in the module identified by a name passed to the function as an argument:
dir(module)

6. Math functions
from math import ceil, floor, trunc

x = 1.4
y = 2.6

print(floor(x), floor(y))
print(floor(-x), floor(-y))
print(ceil(x), ceil(y))
print(ceil(-x), ceil(-y))
print(trunc(x), trunc(y))
print(trunc(-x), trunc(-y))

7. Is there real randomness in computers?
Another module worth mentioning is the one named random
It delivers some mechanisms allowing you to operate with pseudorandom numbers.
"pseudo" - they all are calculated using very refined algorithms.

A random number generator takes a value called a seed, treats it as an input value, calculates a "random" number based on it
and produces a new seed value.
The length of a cycle in which all seed values are unique may be very long, but it isn't infinite - sooner or later the seed values will start repeating, and the generating values will repeat, too

The initial seed value, set during the program start, determines the order in which the generated values will appear.

The random factor of the process may be augmented by setting the seed with a number taken from the current time - this may ensure that each program launch will start from a different seed value

random() - produces a float number x coming from the range (0.0, 1.0) - in other words: (0.0 <= x < 1.0).

The seed function

The seed() function is able to directly set the generator's seed. We'll show you two of its variants:

seed() - sets the seed with the current time;
seed(int_value) - sets the seed with the integer value int_value.

!!! Due to the fact that the seed is always set with the same value, the sequence of generated values always looks the same. !!!


If you want integer random values, one of the following functions would fit better:

randrange(end)
randrange(beg, end)
randrange(beg, end, step)
randint(left, right)

The last function is an equivalent of randrange(left, right+1) - it generates the integer value i, which falls in the range [left, right] (no exclusion on the right side).

The choice and sample functions
It's a function named in a very suggestive way - choice:

choice(sequence)
sample(sequence, elements_to_choose)

Again, the output of the program is not predictable.


8. platform module
The platform module lets you access the underlying platform's data, i.e., hardware, operating system, and interpreter version information.

platform(aliased = False, terse = False)
aliased → when set to True (or any non-zero value) it may cause the function to present the alternative underlying layer names instead of the common ones;
terse → when set to True (or any non-zero value) it may convince the function to present a briefer form of the result (if possible)

from platform import platform

print(platform())
print(platform(1))
print(platform(0, 1))

Windows-10-10.0.19041-SP0
Windows-10-10.0.19041-SP0
Windows-10

9. The machine function
you may just want to know the generic name of the processor which runs your OS together with Python and your code

from platform import machine
print(machine())
>>> AMD64

10. The processor function
The processor() function returns a string filled with the real processor name (if possible).

from platform import processor
print(processor())
>>> Intel64 Family 6 Model 142 Stepping 12, GenuineIntel

11. The system function
A function named system() returns the generic OS name as a string.

from platform import system
print(system())
>>> Windows

12. The version function
The OS version is provided as a string by the version() function.

from platform import version
print(version())
>>> 10.0.19041

13. functions from platform module

python_implementation() → returns a string denoting the Python implementation (expect CPython here, unless you decide to use any non-canonical Python branch)

python_version_tuple() → returns a three-element tuple filled with:
the major part of Python's version;
the minor part;
the patch level number.

from platform import python_implementation, python_version_tuple

print(python_implementation())

for atr in python_version_tuple():
    print(atr)

>>> CPython
3
9
6

14. Python Module Index
You can read about all standard Python modules here: https://docs.python.org/3/py-modindex.html.

15. Key takeaways

1. A function named dir() can show you a list of the entities contained inside an imported module. For example:

import os
dir(os)


prints out the list of all the os module's facilities you can use in your code.


2. The math module couples more than 50 symbols (functions and constants) that perform mathematical operations (like sine(), pow(), factorial()) or providing important values (like π and the Euler symbol e).


3. The random module groups more than 60 entities designed to help you use pseudo-random numbers. Don't forget the prefix "random", as there is no such thing as a real random number when it comes to generating them using the computer's algorithms.


4. The platform module contains about 70 functions which let you dive into the underlaying layers of the OS and hardware. Using them allows you to get to know more about the environment in which your code is executed.


5. Python Module Index (https://docs.python.org/3/py-modindex.html is a community-driven directory of modules available in the Python universe. If you want to find a module fitting your needs, start your search there.



Exercise 1

What is the expected value of the result variable after the following code is executed?

import math
result = math.e == math.exp(1)


Check
True

Exercise 2

(Complete the sentence) Setting the generator's seed with the same value each time your program is run guarantees that...

Check
... the pseudo-random values emitted from the random module will be exactly the same.



Exercise 3

Which of the platform module's functions will you use to determine the name of the CPU running inside your computer?

Check
The processor() function



Exercise 4

What is the expected output of the following snippet?

import platform

print(len(platform.python_version_tuple()))


Check
3

16. What is a package?
making many modules may cause a little mess - sooner or later you'll want to group your modules exactly in the same way as you've previously grouped functions - is there a more general container than a module?
yes, there is - it's a package; in the world of modules, a package plays a similar role to a folder/directory in the world of files.

A new subfolder has appeared - can you see it? Its name is __pycache__
There is a file named (more or less) module.cpython-xy.pyc where x and y are digits derived from your version of Python
When Python imports a module for the first time, it translates its contents into a somewhat compiled shape.
The file doesn't contain machine code - it's internal Python semi-compiled code,  ready to be executed by Python's interpreter
the execution starts faster, and runs faster, too.

Thanks to that, every subsequent import will go quicker than interpreting the source text from scratch.

Python is able to check if the module's source file has been modified (in this case, the pyc file will be rebuilt) or not (when the pyc file may be run at once). As this process is fully automatic and transparent, you don't have to keep it in mind.

When a module is imported, its content is implicitly executed by Python
Note: the initialization takes place only once, when the first import occurs, so the assignments done by the module aren't repeated unnecessarily.

Imagine the following context:

there is a module named mod1;
there is a module named mod2 which contains the import mod1 instruction;
there is a main file containing the import mod1 and import mod2 instructions.
At first glance, you may think that mod1 will be imported twice - fortunately, only the first import occurs. Python remembers the imported modules and silently omits all subsequent imports.

Python can do much more. It also creates a variable called __name__.
We can say that:

when you run a file directly, its __name__ variable is set to __main__;
when a file is imported as a module, its __name__ variable is set to the file's name (excluding .py)

A few elements need some explanation, we think:

the line starting with #! has many names - it may be called shabang, shebang, hashbang, poundbang or even hashpling (don't ask us why). The name itself means nothing here - its role is more important. From Python's point of view, it's just a comment as it starts with #. For Unix and Unix-like OSs (including MacOS) such a line instructs the OS how to execute the contents of the file (in other words, what program needs to be launched to interpret the text). In some environments (especially those connected with web servers) the absence of that line will cause trouble;
a string (maybe a multiline) placed before any module instructions (including imports) is called the doc-string, and should briefly explain the purpose and contents of the module;
the functions defined inside the module (suml() and prodl()) are available for import;
we've used the __name__ variable to detect when the file is run stand-alone, and seized this opportunity to perform some simple tests.

https://edube.org/learn/pe-2/modules-and-packages-34







