https://edube.org/learn/pe-2/python-essentials-2-module-3-1

1. The basic concepts of the object-oriented approach

This kind of understanding of a project's structure makes many important tasks easier, e.g., dividing the project into small, independent parts, and independent development of different project elements.

Python is a universal tool for both object and procedural programming.


2. Procedural vs. the object-oriented approach
In the procedural approach, it's possible to distinguish two different and completely separate worlds: the world of data, and the world of code.
The world of data is populated with variables of different kinds, while the world of code is inhabited by code grouped into modules and functions.
Functions are able to use data, but not vice versa.

The object approach suggests a completely different way of thinking
The data and the code are enclosed together in the same world, divided into classes.
Every class is like a recipe which can be used when you want to create a useful object
All these concepts reflect real facts, relationships, and circumstances.

3. Class hierarchies
superclass, subclass

4. What is an object?
instance of class

5. Inheritance
Any object bound to a specific level of a class hierarchy inherits all the traits (as well as the requirements and qualities) defined inside any of the superclasses.

6. What does an object have?
object has a name that uniquely identifies it within its home namespace
object has a set of individual properties which make it original, unique or outstanding
object has a set of abilities to perform specific activities, able to change the object itself, or some of the other objects.

a noun - you probably define the object's name;
an adjective - you probably define the object's property;
a verb - you probably define the object's activity.

A pink Cadillac went quickly.

Object name = Cadillac
Home class = Wheeled vehicles
Property = Color (pink)
Activity = Go (quickly)

7. Object programming
Object programming is the art of defining and expanding classes.
A class is a model of a very specific part of reality, reflecting properties and activities found in the real world.

The classes defined at the beginning are too general and imprecise to cover the largest possible number of real cases.

There's no obstacle to defining new, more precise subclasses. They'll inherit everything from their superclass, so the work that went into its creation isn't wasted.

The new class may add new properties and new activities, and therefore may be more useful in specific applications. Obviously, it may be used as a superclass for any number of newly created subclasses.

The process doesn't need to have an end. You can create as many classes as you need.

class TheSimplestClass:
    pass

The class is rather poor: it has neither properties nor activities

The newly defined class becomes a tool that is able to create new objects.
The tool has to be used explicitly, on demand.

To do this, you need to assign a variable to store the newly created object of that class, and create an object at the same time.
my_first_object = TheSimplestClass()

The act of creating an object of the selected class is also called an instantiation (as the object becomes an instance of the class).

8.Key takeaways

1. A class is an idea (more or less abstract) which can be used to create a number of incarnations – such an incarnation is called an object.


2. When a class is derived from another class, their relation is named inheritance. The class which derives from the other class is named a subclass. The second side of this relation is named superclass. A way to present such a relation is an inheritance diagram, where:

superclasses are always presented above their subclasses;
relations between classes are shown as arrows directed from the subclass toward its superclass.

3. Objects are equipped with:

a name which identifies them and allows us to distinguish between them;
a set of properties (the set can be empty)
a set of methods (can be empty, too)

4. To define a Python class, you need to use the class keyword. For example:

class This_Is_A_Class:
     pass


5. To create an object of the previously defined class, you need to use the class as if it were a function. For example:

this_is_an_object = This_Is_A_Class()



Exercise 1

If we assume that pythons, vipers, and cobras are subclasses of the same superclass, how would you call it?

Check
Snake, reptile, vertebrate, animal – all these answers are acceptable.


Exercise 2

Try to name a few python class subclasses.

Check
Indian python, African rock python, ball python, Burmese python – the list is long.


Exercise 3

Can you name one of your classes just "class"?

Check
No, you can't – class is a keyword!


9. What is a stack?
A stack is a structure developed to store data in a very specific way
The alternative name for a stack (but only in IT terminology) is LIFO. Last In - First Out

!!! A stack is an object with two elementary operations, conventionally named push (when a new element is put on the top)
and pop (when an existing element is taken away from the top). !!!


The stack - the procedural approach
First, you have to decide how to store the values which will arrive onto the stack. We suggest using the simplest of methods, and employing a list for this job.

stack = []


def push(val):
    stack.append(val)


def pop():
    val = stack[-1]
    del stack[-1]
    return val


push(3)
push(2)
push(1)

print(pop())
print(pop())
print(pop())


The stack - the procedural approach vs. the object-oriented approach

disadvantages:
the essential variable (the stack list) is highly vulnerable; anyone can modify it in an uncontrollable way, destroying the stack, in effect;
it may also happen that one day you need more than one stack; you'll have to create another list for the stack's storage, and probably other push and pop functions too;
it may also happen that you need not only push and pop functions, but also some other conveniences; you could certainly implement them, but try to imagine what would happen if you had dozens of separately implemented stacks.

The objective approach delivers solutions for each of the above problems
the ability to hide (protect) selected values against unauthorized access is called encapsulation; the encapsulated values can be neither accessed nor modified if you want to use them exclusively;
you can produce as many stacks as you want; you needn't copy or replicate any part of the code;
the ability to enrich the stack with new functions comes from inheritance;

The stack - the object approach
def __init__(self) -> Such a function is called a constructor, as its general purpose is to construct a new object.

When any class component has a name starting with two underscores (__), it becomes private - this means that it can be accessed only from within the class.
You cannot see it from the outside world. This is how Python implements the encapsulation concept.

Such a component is called public, so you can't begin its name with two (or more) underscores. There is one more requirement - the name must have no more than one trailing underscore.

class Stack:
    def __init__(self):
        self.__stack_list = []


    def push(self, val):
        self.__stack_list.append(val)


    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


stack_object = Stack()

stack_object.push(3)
stack_object.push(2)
stack_object.push(1)

print(stack_object.pop())
print(stack_object.pop())
print(stack_object.pop())


!!! Here, both functions have a parameter named self at the first position of the parameters list. !!!
It allows the method to access entities (properties and activities/methods) carried out by the actual object. You cannot omit it.
Every time Python invokes a method, it implicitly sends the current object as the first argument.
This means that a method is obligated to have at least one parameter, which is used by Python itself


10. The object approach: a stack from scratch
Let's add a new class for handling stacks.
The new class should be able to evaluate the sum of all the elements currently stored on the stack.

We don't want to modify the previously defined stack.
: just define a new subclass pointing to the class which will be used as the superclass. - It gets all the components defined by its superclass

class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self)
        self.__sum = 0

Contrary to many other languages, Python forces you to explicitly invoke a superclass's constructor.
Omitting this point will have harmful effects - the object will be deprived of the __stack_list list. Such a stack will not function properly.

Note the syntax:

you specify the superclass's name (this is the class whose constructor you want to run)
you put a dot (.)after it;
you specify the name of the constructor;
you have to point to the object (the class's instance) which has to be initialized by the constructor - this is why you have to specify the argument and use the self variable here;

!!! note: invoking any method (including constructors) from outside the class never requires you to put the self argument at the argument's list
- invoking a method from within the class demands explicit usage of the self argument, and it has to be put first on the list.
!!!

class Stack:
    def __init__(self):
        self.__stack_list = []

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self)
        self.__sum = 0

    def get_sum(self):
        return self.__sum

    def push(self, val):
        self.__sum += val
        Stack.push(self, val)

    def pop(self):
        val = Stack.pop(self)
        self.__sum -= val
        return val


stack_object = AddingStack()


Note the way we've invoked the previous implementation of the push method (the one available in the superclass):

we have to specify the superclass's name; this is necessary in order to clearly indicate the class containing the method, to avoid confusing it with any other function of the same name;
we have to specify the target object and to pass it as the first argument (it's not implicitly added to the invocation in this context.)


11. Key takeaways

1. A stack is an object designed to store data using the LIFO model. The stack usually accomplishes at least two operations, named push() and pop().


2. Implementing the stack in a procedural model raises several problems which can be solved by the techniques offered by OOP (Object Oriented Programming):


3. A class method is actually a function declared inside the class and able to access all the class's components.


4. The part of the Python class responsible for creating new objects is called the constructor, and it's implemented as a method of the name __init__.


5. Each class method declaration must contain at least one parameter (always the first one) usually referred to as self, and is used by the objects to identify themselves.


6. If we want to hide any of a class's components from the outside world, we should start its name with __. Such components are called private.



Exercise 1

Assuming that there is a class named Snakes, write the very first line of the Python class declaration, expressing the fact that the new class is actually a subclass of Snake.

Check
class Python(Snakes):



Exercise 2

Something is missing from the following declaration – what?

class Snakes
    def __init__():
        self.sound = 'Sssssss'


Check
The __init__() constructor lacks the obligatory parameter (we should name it self to stay compliant with the standards).



Exercise 3

Modify the code to guarantee that the venomous property is private.

class Snakes
    def __init__(self):
        self.venomous = True


Check
The code should look as follows:

class Snakes
    def __init__(self):
        self.__venomous = True


12. Instance variables; __dict__
https://edube.org/learn/pe-2/oop-properties-24

In general, a class can be equipped with two different kinds of data to form a class's properties
This kind of class property exists when and only when it is explicitly created and added to an object.
this can be done during the object's initialization, performed by the constructor.
Moreover, it can be done in any moment of the object's life.

Such variables (properties) are called instance variables.
The word instance suggests that they are closely connected to the objects (which are class instances), not to the classes themselves.

Python objects, when created, are gifted with a small set of predefined properties and methods. Each object has got them,
 whether you want them or not. One of them is a variable named __dict__ (it's a dictionary).

__dict__ : The variable contains the names and values of all the properties (variables) the object is currently carrying


class ExampleClass:
    def __init__(self, val = 1):
        self.first = val

    def set_second(self, val):
        self.second = val


example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)

example_object_2.set_second(3)

example_object_3 = ExampleClass(4)
example_object_3.third = 5

print(example_object_1.__dict__)
print(example_object_2.__dict__)
print(example_object_3.__dict__)

>>>
{'first': 1}
{'second': 3, 'first': 2}
{'third': 5, 'first': 4}

ExampleClass has a constructor, which unconditionally creates an instance variable named first
the class also has a method which creates another instance variable, named second;

we've created three objects of the class ExampleClass, but all these instances differ:
example_object_1 only has the property named first;
example_object_2 has two properties: first and second;
example_object_3 has been enriched with a property named third just on the fly, outside the class's code - this is possible and fully permissible.

Note: modifying an instance variable of any object has no impact on all the remaining objects.
!!! Instance variables are perfectly isolated from each other. !!!

 two underscores (__)  - makes the instance variable private - it becomes inaccessible from the outer world.

!!!
class ExampleClass:
    def __init__(self, val = 1):
        self.__first = val

    def set_second(self, val = 2):
        self.__second = val

When Python sees that you want to add an instance variable to an object and you're going to do it inside any of
the object's methods, it mangles the operation in the following way:
it puts a class name before your name;
it puts an additional underscore at the beginning.

This is why the __first becomes _ExampleClass__first.
The name is now fully accessible from outside the class.
print(example_object_1._ExampleClass__first)

NOTE: The mangling won't work if you add a private instance variable outside the class code.
In this case, it'll behave like any other ordinary property.

!!!


13. Class variables
A class variable is a property which exists in just one copy and is stored outside any object.

Note: no instance variable exists if there is no object in the class; a class variable exists in one copy even if there are no objects in the class.

Class variables are created differently to their instance siblings.

class ExampleClass:
    counter = 0
    def __init__(self, val = 1):
        self.__first = val
        ExampleClass.counter += 1


example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)
example_object_3 = ExampleClass(4)

print(example_object_1.__dict__, example_object_1.counter)
print(example_object_2.__dict__, example_object_2.counter)
print(example_object_3.__dict__, example_object_3.counter)

>>>
{'_ExampleClass__first': 1} 3
{'_ExampleClass__first': 2} 3
{'_ExampleClass__first': 4} 3


!!! IMPORTANT !!!
class variables aren't shown in an object's __dict__ (this is natural as class variables aren't parts of an object)
but you can always try to look into the variable of the same name, but at the class level - we'll show you this very soon;
a class variable always presents the same value in all class instances (objects)

!!! Mangling a class variable's name has the same effects as those you're already familiar with. !!!

class ExampleClass:
    __counter = 0
    def __init__(self, val = 1):
        self.__first = val
        ExampleClass.__counter += 1


example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)
example_object_3 = ExampleClass(4)

print(example_object_1.__dict__, example_object_1._ExampleClass__counter)
print(example_object_2.__dict__, example_object_2._ExampleClass__counter)
print(example_object_3.__dict__, example_object_3._ExampleClass__counter)

>>>
{'_ExampleClass__first': 1} 3
{'_ExampleClass__first': 2} 3
{'_ExampleClass__first': 4} 3


14. __dict__ difference: class vs. object

Now we're going to take the opportunity to show you the difference between these two __dict__ variables,
the one from the class and the one from the object.

class ExampleClass:
    varia = 1
    def __init__(self, val):
        ExampleClass.varia = val


print(ExampleClass.__dict__)
example_object = ExampleClass(2)

print(ExampleClass.__dict__)
print(example_object.__dict__)

>>>
{'__module__': '__main__', 'varia': 1 ...
{'__module__': '__main__', 'varia': 2 ...
{}

Naming the variable is the most important aspect of the example because:
Changing the assignment to self.varia = val would create an instance variable of the same name as the class's one;
Changing the assignment to varia = val would operate on a !!! method's local variable !!!;
(we strongly encourage you to test both of the above cases - this will make it easier for you to remember the difference)

class' __dict__ contains much more data than its object's counterpart.
Note that the object's __dict__ is empty - the object has no instance variables.


15. Checking an attribute's existence
Python's attitude to object instantiation raises one important issue:
you may not expect that all objects of the same class have the same sets of properties.

class ExampleClass:
    def __init__(self, val):
        if val % 2 != 0:
            self.a = 1
        else:
            self.b = 1


example_object = ExampleClass(1)

print(example_object.a)
print(example_object.b)

>>>
1
Traceback (most recent call last):
  File ".main.py", line 11, in
    print(example_object.b)
AttributeError: 'ExampleClass' object has no attribute 'b'

!!! As you can see, accessing a non-existing object (class) attribute causes an AttributeError exception. !!!

16. hasattr
Python provides a function which is able to safely check if any object/class contains a specified property.

hasattr expects two arguments to be passed to it:
the class or the object being checked;
the name of the property whose existence has to be reported (note: it has to be a string containing the attribute name, not the name alone)
The function returns True or False.

if hasattr(example_object, 'b'):
    print(example_object.b)

Note: better solution than try.. catch..

hasattr() function can operate on classes, too.
You can use it to find out if a class variable is available

!!!

class ExampleClass:
    a = 1
    def __init__(self):
        self.b = 2


example_object = ExampleClass()

print(hasattr(example_object, 'b'))
print(hasattr(example_object, 'a'))
print(hasattr(ExampleClass, 'b'))
print(hasattr(ExampleClass, 'a'))

>>>
True
True
False
True

!!!

17. Key takeaways

1. An instance variable is a property whose existence depends on the creation of an object. Every object can have a different set of instance variables.

Moreover, they can be freely added to and removed from objects during their lifetime. All object instance variables are stored inside a dedicated dictionary named __dict__, contained in every object separately.


2. An instance variable can be private when its name starts with __, but don't forget that such a property is still accessible from outside the class using a mangled name constructed as _ClassName__PrivatePropertyName.


3. A class variable is a property which exists in exactly one copy, and doesn't need any created object to be accessible. Such variables are not shown as __dict__ content.

All a class's class variables are stored inside a dedicated dictionary named __dict__, contained in every class separately.


4. A function named hasattr() can be used to determine if any object/class contains a specified property.

For example:

class Sample:
    gamma = 0 # Class variable.
    def __init__(self):
        self.alpha = 1 # Instance variable.
        self.__delta = 3 # Private instance variable.


obj = Sample()
obj.beta = 2  # Another instance variable (existing only inside the "obj" instance.)
print(obj.__dict__)


The code outputs:

{'alpha': 1, '_Sample__delta': 3, 'beta': 2}
output



Exercise 1

Which of the Python class properties are instance variables and which are class variables? Which of them are private?

class Python:
    population = 1
    victims = 0
    def __init__(self):
        self.length_ft = 3
        self.__venomous = False

Check
population and victims are class variables, while length and __venomous are instance variables (the latter is also private).



Exercise 2

You're going to negate the __venomous property of the version_2 object, ignoring the fact that the property is private. How will you do this?

version_2 = Python()


Check
version_2._Python__venomous = not version_2._Python__venomous



Exercise 3

Write an expression which checks if the version_2 object contains an instance property named constrictor (yes, constrictor!).

Check
hasattr(version_2, 'constrictor')

18.
https://edube.org/learn/pe-2/section-summary-102

18. Methods in detail
method is a function embedded inside a class.
a method is obliged to have at least one parameter (self)

The name self suggests the parameter's purpose - it identifies the object for which the method is invoked.

If you're going to invoke a method, you mustn't pass the argument for the self parameter - Python will set it for you.

The self parameter is used to obtain access to the object's instance and class variables.

class Classy:
    varia = 2
    def method(self):
        print(self.varia, self.var)

The self parameter is also used to invoke other object/class methods from inside the class.

class Classy:
    def other(self):
        print("other")

    def method(self):
        print("method")
        self.other()


__init__
If a class has a constructor, it is invoked automatically and implicitly when the object of the class is instantiated.

The constructor:

is obliged to have the self parameter (it's set automatically, as usual);
may (but doesn't need to) have more parameters than just self; if this happens, the way in which the class name is used
to create the object must reflect the __init__ definition;
can be used to set up the object, i.e., properly initialize its internal state, create instance variables, instantiate
any other objects if their existence is needed, etc.

Note that the constructor:

cannot return a value, as it is designed to return a newly created object and nothing else;
cannot be invoked directly either from the object or from inside the class

property name mangling applies to method names, too

class Classy:
    def visible(self):
        print("visible")

    def __hidden(self):
        print("hidden")


obj = Classy()
obj.visible()

try:
    obj.__hidden()
except:
    print("failed")

obj._Classy__hidden()


19. The inner life of classes and objects
__dict__ is a dictionary. Another built-in property worth mentioning is __name__, which is a string.

Note: the __name__ attribute is absent from the object - it exists only inside classes.

class Classy:
    pass


print(Classy.__name__)
obj = Classy()
print(type(obj).__name__)
print(obj.__name__)

>>>
Classy
Classy
Traceback (most recent call last):
  File "main.py", line 8, in <module>
    print(obj.__name__)
AttributeError: 'Classy' object has no attribute '__name__'


If you want to find the class of a particular object, you can use a function named type(),
which is able (among other things) to find a class which has been used to instantiate any object.

20.The inner life of classes and objects: continued
__module__ is a string, too - it stores the name of the module which contains the definition of the class.

class Classy:
    pass


print(Classy.__module__)
obj = Classy()
print(obj.__module__)

>>>
__main__
__main__


21. The inner life of classes and objects: continued
__bases__ is a tuple. The tuple contains classes (not class names) which are direct superclasses for the class.
The order is the same as that used inside the class definition.

!!! Note: only classes have this attribute - objects don't. !!!


22. Reflection and introspection

introspection, which is the ability of a program to examine the type or properties of an object at runtime;
reflection, which goes a step further, and is the ability of a program to manipulate the values, properties and/or functions of an object at runtime.

In other words, you don't have to know a complete class/object definition to manipulate the object, as the object and/or
its class contain the metadata allowing you to recognize its features during program execution.

23. Investigating classes

The function named incIntsI() gets an object of any class, scans its contents in order to find all integer
attributes with names starting with i, and increments them by one.

class MyClass:
    pass

obj = MyClass()
obj.a = 1
obj.b = 2
obj.i = 3
obj.ireal = 3.5
obj.integer = 4
obj.z = 5


def incIntsI(obj):
    for name in obj.__dict__.keys():
        if name.startswith('i'):
            val = getattr(obj, name)
            if isinstance(val, int):
                setattr(obj, name, val + 1)


print(obj.__dict__)
incIntsI(obj)
print(obj.__dict__)

>>>
{'a': 1, 'b': 2, 'i': 3, 'ireal': 3.5, 'integer': 4, 'z': 5}
{'a': 1, 'b': 2, 'i': 4, 'ireal': 3.5, 'integer': 5, 'z': 5}

24. Key takeaways

1. A method is a function embedded inside a class. The first (or only) parameter of each method is usually named self, which is designed to identify the object for which the method is invoked in order to access the object's properties or invoke its methods.


2. If a class contains a constructor (a method named __init__) it cannot return any value and cannot be invoked directly.


3. All classes (but not objects) contain a property named __name__, which stores the name of the class. Additionally, a property named __module__ stores the name of the module in which the class has been declared, while the property named __bases__ is a tuple containing a class's superclasses.

For example:

class Sample:
    def __init__(self):
        self.name = Sample.__name__
    def myself(self):
        print("My name is " + self.name + " living in a " + Sample.__module__)


obj = Sample()
obj.myself()


The code outputs:

My name is Sample living in a __main__
output



Exercise 1

The declaration of the Snake class is given below. Enrich the class with a method named increment(), adding 1 to the __victims property.

class Snake:
    def __init__(self):
        self.victims = 0

Check
class Snake:
    def __init__(self):
        self.victims = 0

    def increment(self):
        self.victims += 1




Exercise 2

Redefine the Snake class constructor so that is has a parameter to initialize the victims field with a value passed to the object during construction.


Check
class Snake:
    def __init__(self, victims):
        self.victims = victims



Exercise 3

Can you predict the output of the following code?

class Snake:
    pass


class Python(Snake):
    pass


print(Python.__name__, 'is a', Snake.__name__)
print(Python.__bases__[0].__name__, 'can be', Python.__name__)


Check
Python is a Snake
Snake can be Python


25. Inheritance - why and how?

The default __str__() method returns the previous string - ugly and not very informative. You can change it just by defining your own method of the name.

class Star:
    def __init__(self, name, galaxy):
        self.name = name
        self.galaxy = galaxy

    def __str__(self):
        return self.name + ' in ' + self.galaxy


sun = Star("Sun", "Milky Way")
print(sun)


Inheritance is a common practice (in object programming) of passing attributes and methods from the superclass (defined
and existing) to a newly created class, called the subclass.

In other words, inheritance is a way of building a new class, not from scratch, but by using an already defined repertoire of traits.

The new class inherits (and this is the key) all the already existing equipment, but is able to add some new ones if needed.

Thanks to that, it's possible to build more specialized (more concrete) classes using some sets of predefined general rules and behaviors

superclass / subclass


26. issubclass()
able to identify a relationship between two classes,
it can check if a particular class is a subclass of any other class.

issubclass(ClassOne, ClassTwo)

Note: each class is considered to be a subclass of itself.
Note2: only works on classes!!! not objects (TypeError)

27. isinstance()
an object is an incarnation of a class
whether it is an object of a certain class or not.

isinstance(objectName, ClassName)

first arg can be object, 2nd arg must BE class (type) - otherwise TypeError

Being an instance of a class means that the object (the cake) has been prepared using a recipe contained in either the class or one of its superclasses.


28. Inheritance: the is operator
The is operator checks whether two variables (object_one and object_two here) refer to the same object.

!!! variables don't store the objects themselves, but only the handles pointing to the internal Python memory.!!!
!!! Assigning a value of an object variable to another variable doesn't copy the object, but only its handle. !!!

29. How Python finds properties and methods

Note: As there is no __str__() method within the Sub class, the printed string is to be produced within the Super class.
This means that the __str__() method has been inherited by the Sub class.

class Super:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return "My name is " + self.name + "."


class Sub(Super):
    def __init__(self, name):
        Super.__init__(self, name)


obj = Sub("Andy")

print(obj)

>>>
My name is Andy.

https://edube.org/learn/pe-2/oop-fundamentals-inheritance-64


30. How Python finds properties and methods
make use of the super() function, which accesses the superclass without needing to know its name:

super().__init__(name)

The super() function creates a context in which you don't have to (moreover, you mustn't) pass the self argument to the method being invoked
Super.__init__(self, name) // the same as: super().__init__(name)

!!! Note: you can use this mechanism not only to invoke the superclass constructor,
but also to get access to any of the resources available inside the superclass. !!!

class Super:
    supVar = 1


class Sub(Super):
    subVar = 2


obj = Sub()

print(obj.subVar)
print(obj.supVar)

>>>
2
1

The same effect can be observed with instance variables
class Super:
    def __init__(self):
        self.supVar = 11


class Sub(Super):
    def __init__(self):
        super().__init__()
        self.subVar = 12


obj = Sub()

print(obj.subVar)
print(obj.supVar)

>>>
12
11

!!! Note: the existence of the supVar variable is obviously conditioned by the Super class constructor invocation.
Omitting it would result in the absence of the variable in the created object !!!

31. How Python finds properties and methods: continued

a general statement describing Python's behavior:
When you try to access any object's entity, Python will try to (in this order):
find it inside the object itself;
find it in all classes involved in the object's inheritance line from bottom to top;
If both of the above fail, an exception (AttributeError) is raised.

class Level1:
    variable_1 = 100
    def __init__(self):
        self.var_1 = 101

    def fun_1(self):
        return 102


class Level2(Level1):
    variable_2 = 200
    def __init__(self):
        super().__init__()
        self.var_2 = 201

    def fun_2(self):
        return 202


class Level3(Level2):
    variable_3 = 300
    def __init__(self):
        super().__init__()
        self.var_3 = 301

    def fun_3(self):
        return 302


obj = Level3()

print(obj.variable_1, obj.var_1, obj.fun_1())
print(obj.variable_2, obj.var_2, obj.fun_2())
print(obj.variable_3, obj.var_3, obj.fun_3())

>>>
100 101 102
200 201 202
300 301 302

32. Multiple inheritance
Multiple inheritance occurs when a class has more than one superclass.

Syntactically, such inheritance is presented as a comma-separated list of superclasses put inside parentheses after the new class name

class Sub(SuperA, SuperB):
    pass

his means that the Sub class inherits all the goods offered by both SuperA and SuperB.

33. overriding
The entity defined later (in the inheritance sense) overrides the same entity defined earlier.

class Level1:
    var = 100
    def fun(self):
        return 101


class Level2(Level1):
    var = 200
    def fun(self):
        return 201


class Level3(Level2):
    pass


obj = Level3()

print(obj.var, obj.fun())

>>>
200 201

This feature can be intentionally used to modify default (or previously defined) class behaviors
when any of its classes needs to act in a different way to its ancestor.

!!! Python looks for an entity from bottom to top !!!

class Left:
    var = "L"
    var_left = "LL"
    def fun(self):
        return "Left"


class Right:
    var = "R"
    var_right = "RR"
    def fun(self):
        return "Right"


class Sub(Left, Right):
    pass


obj = Sub()

print(obj.var, obj.var_left, obj.var_right, obj.fun())

>>>
L LL RR Left

!!!

We can say that Python looks for object components in the following order:

inside the object itself;
in its superclasses, from bottom to top;
if there is more than one class on a particular inheritance path, Python scans them from left to right.

!!!

34. How to build a hierarchy of classes
https://edube.org/learn/pe-2/oop-fundamentals-inheritance-71


class One:
    def do_it(self):
        print("do_it from One")

    def doanything(self):
        self.do_it()


class Two(One):
    def do_it(self):
        print("do_it from Two")


one = One()
two = Two()

one.doanything()
two.doanything()

>>>
do_it from One
do_it from Two


Note: the situation in which the subclass is able to modify its superclass behavior (just like in the example) is called polymorphism

The method, redefined in any of the superclasses, thus changing the behavior of the superclass, is called virtual.

Each class's behavior may be modified at any time by any of its subclasses.

how to use polymorphism to extend class flexibility.?



import time

class TrackedVehicle:
    def control_track(left, stop):
        pass

    def turn(left):
        control_track(left, True)
        time.sleep(0.25)
        control_track(left, False)


class WheeledVehicle:
    def turn_front_wheels(left, on):
        pass

    def turn(left):
        turn_front_wheels(left, True)
        time.sleep(0.25)
        turn_front_wheels(left, False)


what's wrong with the code?
Let's rebuild the code - we're going to introduce a superclass to gather all the similar aspects of the driving vehicles,
moving all the specifics to the subclasses.

35. How to build a hierarchy of classes: continued
import time

class Vehicle:
    def change_direction(left, on):
        pass

    def turn(left):
        change_direction(left, True)
        time.sleep(0.25)
        change_direction(left, False)


class TrackedVehicle(Vehicle):
    def control_track(left, stop):
        pass

    def change_direction(left, on):
        control_track(left, on)


class WheeledVehicle(Vehicle):
    def turn_front_wheels(left, on):
        pass

    def change_direction(left, on):
        turn_front_wheels(left, on)

Look at the code in the editor again. This is what we've done:

we defined a superclass named Vehicle, which uses the turn() method to implement a general scheme of turning,
while the turning itself is done by a method named change_direction(); note: the former method is empty,
as we are going to put all the details into the subclass (such a method is often called an abstract method,
as it only demonstrates some possibility which will be instantiated later)
we defined a subclass named TrackedVehicle (note: it's derived from the Vehicle class) which instantiated
the change_direction() method by using the specific (concrete) method named control_track()
respectively, the subclass named WheeledVehicle does the same trick, but uses the turn_front_wheels() method to force the vehicle to turn.
The most important advantage (omitting readability issues) is that this form of code enables you to implement
a brand new turning algorithm just by modifying the turn() method, which can be done in just one place, as all the vehicles will obey it.

This is how polymorphism helps the developer to keep the code clean and consistent.


36. Composition
Composition is the process of composing an object using other different objects.

It can be said that:

inheritance extends a class's capabilities by adding new components and modifying existing ones; in other words,
the complete recipe is contained inside the class itself and all its ancestors; the object takes all the class's
belongings and makes use of them;

composition projects a class as a container able to store and use other objects (derived from other classes) where
each of the objects implements a part of a desired class's behavior.

import time

class Tracks:
    def change_direction(self, left, on):
        print("tracks: ", left, on)


class Wheels:
    def change_direction(self, left, on):
        print("wheels: ", left, on)


class Vehicle:
    def __init__(self, controller):
        self.controller = controller

    def turn(self, left):
        self.controller.change_direction(left, True)
        time.sleep(0.25)
        self.controller.change_direction(left, False)


wheeled = Vehicle(Wheels())
tracked = Vehicle(Tracks())

wheeled.turn(True)
tracked.turn(False)


In inheritance: the top-most class was aware of the general rules used in turning the vehicle

In composition: The class - like in the previous example - is aware of how to turn the vehicle,
but the actual turn is done by a specialized object stored in a property named controller

There are two classes named Tracks and Wheels - they know how to control the vehicle's direction.
In this way, the vehicle's ability to turn is composed using an external object, not implemented inside the Vehicle class.

!!! In other words, we have a universal vehicle and can install either tracks or wheels onto it. !!!


37. Single inheritance vs. multiple inheritance
The fact that you can do it does not mean you have to.
multiple inheritance is always risky, as you have many more opportunities to make a mistake in identifying these parts
of the superclasses which will effectively influence the new class;

may make overriding extremely tricky; moreover, using the super() function becomes ambiguous;

multiple inheritance violates the single responsibility principle as it makes a new class of two (or more) classes
that know nothing about each other;

we strongly suggest multiple inheritance as the last of all possible solutions


38. Method Resolution Order (MRO)
strategy in which a particular programming language scans through the upper part of a class’s hierarchy
in order to find the method it currently needs

class Top:
    def m_top(self):
        print("top")


class Middle(Top):
    def m_middle(self):
        print("middle")


class Bottom(Middle, Top):
    def m_bottom(self):
        print("bottom")


!!! the order in which the two superclasses have been listed between parenthesis is compliant with the code's structure !!!


class Top:
    def m_top(self):
        print("top")


class Middle(Top):
    def m_middle(self):
        print("middle")


class Bottom(Top, Middle):
    def m_bottom(self):
        print("bottom")


object = Bottom()
object.m_bottom()
object.m_middle()
object.m_top()

>>>
Traceback (most recent call last):
  File "main.py", line 11, in <module>
    class Bottom(Top, Middle):
TypeError: Cannot create a consistent method resolution
order (MRO) for bases Top, Middle

!!!

it won't run anymore.
The order we tried to force (Top, Middle) is incompatible with the inheritance path
which is derived from the code's structure.

!!!

39. The diamond problem
class A:
    pass


class B(A):
    pass


class C(A):
    pass


class D(B, C):
    pass


d = D()


40. Key takeaways

1. A method named __str__() is responsible for converting an object's contents into a (more or less) readable string.
You can redefine it if you want your object to be able to present itself in a more elegant form. For example:

class Mouse:
    def __init__(self, name):
        self.my_name = name


    def __str__(self):
        return self.my_name


the_mouse = Mouse('mickey')
print(the_mouse)  # Prints "mickey".


2. A function named issubclass(Class_1, Class_2) is able to determine if Class_1 is a subclass of Class_2. For example:

class Mouse:
    pass


class LabMouse(Mouse):
    pass


print(issubclass(Mouse, LabMouse), issubclass(LabMouse, Mouse))  # Prints "False True"


3. A function named isinstance(Object, Class) checks if an object comes from an indicated class. For example:

class Mouse:
    pass


class LabMouse(Mouse):
    pass


mickey = Mouse()
print(isinstance(mickey, Mouse), isinstance(mickey, LabMouse))  # Prints "True False".


4. A operator called is checks if two variables refer to the same object. For example:

class Mouse:
    pass


mickey = Mouse()
minnie = Mouse()
cloned_mickey = mickey
print(mickey is minnie, mickey is cloned_mickey)  # Prints "False True".



5. A parameterless function named super() returns a reference to the nearest superclass of the class. For example:

class Mouse:
    def __str__(self):
        return "Mouse"


class LabMouse(Mouse):
    def __str__(self):
        return "Laboratory " + super().__str__()


doctor_mouse = LabMouse();
print(doctor_mouse)  # Prints "Laboratory Mouse".


6. Methods as well as instance and class variables defined in a superclass are automatically inherited by their subclasses.
For example:

class Mouse:
    Population = 0
    def __init__(self, name):
        Mouse.Population += 1
        self.name = name

    def __str__(self):
        return "Hi, my name is " + self.name

class LabMouse(Mouse):
    pass

professor_mouse = LabMouse("Professor Mouser")
print(professor_mouse, Mouse.Population)  # Prints "Hi, my name is Professor Mouser 1"


7. In order to find any object/class property, Python looks for it inside:

the object itself;
all classes involved in the object's inheritance line from bottom to top;
if there is more than one class on a particular inheritance path, Python scans them from left to right;
if both of the above fail, the AttributeError exception is raised.

8. If any of the subclasses defines a method/class variable/instance variable of the same name as existing in
the superclass, the new name overrides any of the previous instances of the name. For example:

class Mouse:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return "My name is " + self.name

class AncientMouse(Mouse):
    def __str__(self):
        return "Meum nomen est " + self.name

mus = AncientMouse("Caesar")  # Prints "Meum nomen est Caesar"
print(mus)

41. Exercises
Exercises
Scenario

Assume that the following piece of code has been successfully executed:

class Dog:
    kennel = 0
    def __init__(self, breed):
        self.breed = breed
        Dog.kennel += 1
    def __str__(self):
        return self.breed + " says: Woof!"


class SheepDog(Dog):
    def __str__(self):
        return super().__str__() + " Don't run away, Little Lamb!"


class GuardDog(Dog):
    def __str__(self):
        return super().__str__() + " Stay where you are, Mister Intruder!"


rocky = SheepDog("Collie")
luna = GuardDog("Dobermann")


Now answer the questions from exercises 1-4.



Exercise 1

What is the expected output of the following piece of code?

print(rocky)
print(luna)

Check
Collie says: Woof! Don't run away, Little Lamb!
Dobermann says: Woof! Stay where you are, Mister Intruder!



Exercise 2

What is the expected output of the following piece of code?

print(issubclass(SheepDog, Dog), issubclass(SheepDog, GuardDog))
print(isinstance(rocky, GuardDog), isinstance(luna, GuardDog))

Check
True False
False True



Exercise 3

What is the expected output of the following piece of code?

print(luna is luna, rocky is luna)
print(rocky.kennel)

Check
True False
2



Exercise 4

Define a SheepDog's subclass named LowlandDog, and equip it with an __str__() method overriding an inherited method of
the same name. The new dog's __str__() method should return the string "Woof! I don't like mountains!" .

Check
class LowlandDog(SheepDog):
	def __str__(self):
		return Dog.__str__(self) + " I don't like mountains!"

42. More about exceptions
https://edube.org/learn/pe-2/exceptions-once-again-24

def reciprocal(n):
    try:
        n = 1 / n
    except ZeroDivisionError:
        print("Division failed")
        n = None
    else:
        print("Everything went fine")
    finally:
        print("It's time to say goodbye")
        return n


print(reciprocal(2))
print(reciprocal(0))

>>>
Everything went fine
It's time to say good bye
0.5
Division failed
It's time to say good bye
None


43. Exceptions are classes
when an exception is raised, an object of the class is instantiated, and goes through all levels of program execution,
looking for the except branch that is prepared to deal with it.

to catch the exception object:
try:
    i = int("Hello!")
except Exception as e:
    print(e)
    print(e.__str__())

>>>
invalid literal for int() with base 10: 'Hello!'
invalid literal for int() with base 10: 'Hello!'

All the built-in Python exceptions form a hierarchy of classes.
!!! There is no obstacle to extending it if you find it reasonable.

Exception.__subclasses__()
>>>
returns list like:
[<class 'TypeError'>, <class 'StopAsyncIteration'>, <class 'StopIteration'>, ...]


44. Detailed anatomy of exceptions
The BaseException class introduces a property named args. It's a tuple designed to gather all arguments passed to the class constructor
It is empty if the construct has been invoked without any arguments,
or contains just one element when the constructor gets one argument (we don't count the self argument here), and so on.

def print_args(args):
    lng = len(args)
    if lng == 0:
        print("")
    elif lng == 1:
        print(args[0])
    else:
        print(str(args))


try:
    raise Exception
except Exception as e:
    print(e, e.__str__(), sep=' : ' ,end=' : ')
    print_args(e.args)

try:
    raise Exception("my exception")
except Exception as e:
    print(e, e.__str__(), sep=' : ', end=' : ')
    print_args(e.args)

try:
    raise Exception("my", "exception")
except Exception as e:
    print(e, e.__str__(), sep=' : ', end=' : ')
    print_args(e.args)

>>>
:  :
my exception : my exception : my exception
('my', 'exception') : ('my', 'exception') : ('my', 'exception')



try:
    raise Exception("my exception")
except Exception as e:
    print(e.args)

>>>
('my exception',)


45. How to create your own exception
https://edube.org/learn/pe-2/exceptions-once-again-29

This is done by defining your own, new exceptions as subclasses derived from predefined ones.

class MyZeroDivisionError(ZeroDivisionError):
    pass

Note: if you want to create an exception which will be utilized as a specialized case of any built-in exception,
derive it from just this one. If you want to build your own hierarchy, and don't want it to be closely
connected to Python's exception tree, derive it from any of the top exception classes, like Exception.


you may want to build your own exception structure.
You can start building it by defining a general exception as a new base class for any other specialized exception

class PizzaError(Exception):
    def __init__(self, pizza, message):
        Exception.__init__(self, message)
        self.pizza = pizza


class TooMuchCheeseError(PizzaError):
    def __init__(self, pizza, cheese, message):
        PizzaError._init__(self, pizza, message)
        self.cheese = cheese


The TooMuchCheeseError exception needs more information than the regular PizzaError exception,
so we add it to the constructor - the name cheese is then stored for further processing.

# 1
class PizzaError(Exception):
    def __init__(self, pizza, message):
        Exception.__init__(self, message)
        self.pizza = pizza


class TooMuchCheeseError(PizzaError):
    def __init__(self, pizza, cheese, message):
        # super().__init__(pizza, message)
        self.cheese = cheese


def make_pizza(pizza, cheese):
    if pizza not in ['margherita', 'capricciosa', 'calzone']:
        raise PizzaError(pizza, "no such pizza on the menu")
    if cheese > 100:
        raise TooMuchCheeseError(pizza, cheese, "too much cheese")
    print("Pizza ready!")

for (pz, ch) in [('calzone', 0), ('margherita', 110), ('mafia', 20)]:
    try:
        make_pizza(pz, ch)
    except TooMuchCheeseError as tmce:
        print(tmce, ':', tmce.cheese)
    except PizzaError as pe:
        print(pe, ':', pe.pizza)

>>>
Pizza ready!
('margherita', 110, 'too much cheese') : 110
no such pizza on the menu : mafia


class PizzaError(Exception):
    def __init__(self, pizza, message):
        Exception.__init__(self, message)
        self.pizza = pizza


class TooMuchCheeseError(PizzaError):
    def __init__(self, pizza, cheese, message):
        super().__init__(pizza, message)
        self.cheese = cheese


def make_pizza(pizza, cheese):
    if pizza not in ['margherita', 'capricciosa', 'calzone']:
        raise PizzaError(pizza, "no such pizza on the menu")
    if cheese > 100:
        raise TooMuchCheeseError(pizza, cheese, "too much cheese")
    print("Pizza ready!")

for (pz, ch) in [('calzone', 0), ('margherita', 110), ('mafia', 20)]:
    try:
        make_pizza(pz, ch)
    except TooMuchCheeseError as tmce:
        print(tmce, ':', tmce.cheese)
    except PizzaError as pe:
        print(pe, ':', pe.pizza)

>>>
Pizza ready!
too much cheese : 110
no such pizza on the menu : mafia


Another sapmle with default args:
class PizzaError(Exception):
    def __init__(self, pizza='uknown', message=''):
        Exception.__init__(self, message)
        self.pizza = pizza


class TooMuchCheeseError(PizzaError):
    def __init__(self, pizza='uknown', cheese='>100', message=''):
        PizzaError.__init__(self, pizza, message)
        self.cheese = cheese


def make_pizza(pizza, cheese):
    if pizza not in ['margherita', 'capricciosa', 'calzone']:
        raise PizzaError
    if cheese > 100:
        raise TooMuchCheeseError
    print("Pizza ready!")


for (pz, ch) in [('calzone', 0), ('margherita', 110), ('mafia', 20)]:
    try:
        make_pizza(pz, ch)
    except TooMuchCheeseError as tmce:
        print(tmce, ':', tmce.cheese)
    except PizzaError as pe:
        print(pe, ':', pe.pizza)

>>>
Pizza ready!
 : >100
 : uknown


46. Key takeaways

1. The else: branch of the try statement is executed when there has been no exception during the execution of the try: block.


2. The finally: branch of the try statement is always executed.


3. The syntax except Exception_Name as an exception_object: lets you intercept an object carrying information about
a pending exception. The object's property named args (a tuple) stores all arguments passed to the object's constructor.


4. The exception classes can be extended to enrich them with new capabilities, or to adopt their traits to newly defined exceptions.

For example:

try:
    assert __name__ == "__main__"
except:
    print("fail", end=' ')
else:
    print("success", end=' ')
finally:
    print("done")


The code outputs: success done.


Exercise 1

What is the expected output of the following code?

import math

try:
    print(math.sqrt(9))
except ValueError:
    print("inf")
else:
    print("fine")


Check
3.0
fine



Exercise 2

What is the expected output of the following code?

import math

try:
    print(math.sqrt(-9))
except ValueError:
    print("inf")
else:
    print("fine")
finally:
    print("the end")


Check
inf
the end


Exercise 3

What is the expected output of the following code?

import math

class NewValueError(ValueError):
    def __init__(self, name, color, state):
        self.data = (name, color, state)

try:
    raise NewValueError("Enemy warning", "Red alert", "High readiness")
except NewValueError as nve:
    for arg in nve.args:
        print(arg, end='! ')


Check
Enemy warning! Red alert! High readiness!

https://edube.org/learn/pe-2/module-completion-33















