https://edube.org/learn/pe-2/python-essentials-2-module-3-1

1. The basic concepts of the object-oriented approach

This kind of understanding of a project's structure makes many important tasks easier, e.g., dividing the project into small, independent parts, and independent development of different project elements.

Python is a universal tool for both object and procedural programming.


2. Procedural vs. the object-oriented approach
In the procedural approach, it's possible to distinguish two different and completely separate worlds: the world of data, and the world of code.
The world of data is populated with variables of different kinds, while the world of code is inhabited by code grouped into modules and functions.
Functions are able to use data, but not vice versa.

The object approach suggests a completely different way of thinking
The data and the code are enclosed together in the same world, divided into classes.
Every class is like a recipe which can be used when you want to create a useful object
All these concepts reflect real facts, relationships, and circumstances.

3. Class hierarchies
superclass, subclass

4. What is an object?
instance of class

5. Inheritance
Any object bound to a specific level of a class hierarchy inherits all the traits (as well as the requirements and qualities) defined inside any of the superclasses.

6. What does an object have?
object has a name that uniquely identifies it within its home namespace
object has a set of individual properties which make it original, unique or outstanding
object has a set of abilities to perform specific activities, able to change the object itself, or some of the other objects.

a noun - you probably define the object's name;
an adjective - you probably define the object's property;
a verb - you probably define the object's activity.

A pink Cadillac went quickly.

Object name = Cadillac
Home class = Wheeled vehicles
Property = Color (pink)
Activity = Go (quickly)

7. Object programming
Object programming is the art of defining and expanding classes.
A class is a model of a very specific part of reality, reflecting properties and activities found in the real world.

The classes defined at the beginning are too general and imprecise to cover the largest possible number of real cases.

There's no obstacle to defining new, more precise subclasses. They'll inherit everything from their superclass, so the work that went into its creation isn't wasted.

The new class may add new properties and new activities, and therefore may be more useful in specific applications. Obviously, it may be used as a superclass for any number of newly created subclasses.

The process doesn't need to have an end. You can create as many classes as you need.

class TheSimplestClass:
    pass

The class is rather poor: it has neither properties nor activities

The newly defined class becomes a tool that is able to create new objects.
The tool has to be used explicitly, on demand.

To do this, you need to assign a variable to store the newly created object of that class, and create an object at the same time.
my_first_object = TheSimplestClass()

The act of creating an object of the selected class is also called an instantiation (as the object becomes an instance of the class).

8.Key takeaways

1. A class is an idea (more or less abstract) which can be used to create a number of incarnations – such an incarnation is called an object.


2. When a class is derived from another class, their relation is named inheritance. The class which derives from the other class is named a subclass. The second side of this relation is named superclass. A way to present such a relation is an inheritance diagram, where:

superclasses are always presented above their subclasses;
relations between classes are shown as arrows directed from the subclass toward its superclass.

3. Objects are equipped with:

a name which identifies them and allows us to distinguish between them;
a set of properties (the set can be empty)
a set of methods (can be empty, too)

4. To define a Python class, you need to use the class keyword. For example:

class This_Is_A_Class:
     pass


5. To create an object of the previously defined class, you need to use the class as if it were a function. For example:

this_is_an_object = This_Is_A_Class()



Exercise 1

If we assume that pythons, vipers, and cobras are subclasses of the same superclass, how would you call it?

Check
Snake, reptile, vertebrate, animal – all these answers are acceptable.


Exercise 2

Try to name a few python class subclasses.

Check
Indian python, African rock python, ball python, Burmese python – the list is long.


Exercise 3

Can you name one of your classes just "class"?

Check
No, you can't – class is a keyword!


9. What is a stack?
A stack is a structure developed to store data in a very specific way
The alternative name for a stack (but only in IT terminology) is LIFO. Last In - First Out

!!! A stack is an object with two elementary operations, conventionally named push (when a new element is put on the top)
and pop (when an existing element is taken away from the top). !!!


The stack - the procedural approach
First, you have to decide how to store the values which will arrive onto the stack. We suggest using the simplest of methods, and employing a list for this job.

stack = []


def push(val):
    stack.append(val)


def pop():
    val = stack[-1]
    del stack[-1]
    return val


push(3)
push(2)
push(1)

print(pop())
print(pop())
print(pop())


The stack - the procedural approach vs. the object-oriented approach

disadvantages:
the essential variable (the stack list) is highly vulnerable; anyone can modify it in an uncontrollable way, destroying the stack, in effect;
it may also happen that one day you need more than one stack; you'll have to create another list for the stack's storage, and probably other push and pop functions too;
it may also happen that you need not only push and pop functions, but also some other conveniences; you could certainly implement them, but try to imagine what would happen if you had dozens of separately implemented stacks.

The objective approach delivers solutions for each of the above problems
the ability to hide (protect) selected values against unauthorized access is called encapsulation; the encapsulated values can be neither accessed nor modified if you want to use them exclusively;
you can produce as many stacks as you want; you needn't copy or replicate any part of the code;
the ability to enrich the stack with new functions comes from inheritance;

The stack - the object approach
def __init__(self) -> Such a function is called a constructor, as its general purpose is to construct a new object.

When any class component has a name starting with two underscores (__), it becomes private - this means that it can be accessed only from within the class.
You cannot see it from the outside world. This is how Python implements the encapsulation concept.

Such a component is called public, so you can't begin its name with two (or more) underscores. There is one more requirement - the name must have no more than one trailing underscore.

class Stack:
    def __init__(self):
        self.__stack_list = []


    def push(self, val):
        self.__stack_list.append(val)


    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


stack_object = Stack()

stack_object.push(3)
stack_object.push(2)
stack_object.push(1)

print(stack_object.pop())
print(stack_object.pop())
print(stack_object.pop())


!!! Here, both functions have a parameter named self at the first position of the parameters list. !!!
It allows the method to access entities (properties and activities/methods) carried out by the actual object. You cannot omit it.
Every time Python invokes a method, it implicitly sends the current object as the first argument.
This means that a method is obligated to have at least one parameter, which is used by Python itself


10. The object approach: a stack from scratch
Let's add a new class for handling stacks.
The new class should be able to evaluate the sum of all the elements currently stored on the stack.

We don't want to modify the previously defined stack.
: just define a new subclass pointing to the class which will be used as the superclass. - It gets all the components defined by its superclass

class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self)
        self.__sum = 0

Contrary to many other languages, Python forces you to explicitly invoke a superclass's constructor.
Omitting this point will have harmful effects - the object will be deprived of the __stack_list list. Such a stack will not function properly.

Note the syntax:

you specify the superclass's name (this is the class whose constructor you want to run)
you put a dot (.)after it;
you specify the name of the constructor;
you have to point to the object (the class's instance) which has to be initialized by the constructor - this is why you have to specify the argument and use the self variable here;

!!! note: invoking any method (including constructors) from outside the class never requires you to put the self argument at the argument's list
- invoking a method from within the class demands explicit usage of the self argument, and it has to be put first on the list.
!!!

class Stack:
    def __init__(self):
        self.__stack_list = []

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self)
        self.__sum = 0

    def get_sum(self):
        return self.__sum

    def push(self, val):
        self.__sum += val
        Stack.push(self, val)

    def pop(self):
        val = Stack.pop(self)
        self.__sum -= val
        return val


stack_object = AddingStack()


Note the way we've invoked the previous implementation of the push method (the one available in the superclass):

we have to specify the superclass's name; this is necessary in order to clearly indicate the class containing the method, to avoid confusing it with any other function of the same name;
we have to specify the target object and to pass it as the first argument (it's not implicitly added to the invocation in this context.)


11. Key takeaways

1. A stack is an object designed to store data using the LIFO model. The stack usually accomplishes at least two operations, named push() and pop().


2. Implementing the stack in a procedural model raises several problems which can be solved by the techniques offered by OOP (Object Oriented Programming):


3. A class method is actually a function declared inside the class and able to access all the class's components.


4. The part of the Python class responsible for creating new objects is called the constructor, and it's implemented as a method of the name __init__.


5. Each class method declaration must contain at least one parameter (always the first one) usually referred to as self, and is used by the objects to identify themselves.


6. If we want to hide any of a class's components from the outside world, we should start its name with __. Such components are called private.



Exercise 1

Assuming that there is a class named Snakes, write the very first line of the Python class declaration, expressing the fact that the new class is actually a subclass of Snake.

Check
class Python(Snakes):



Exercise 2

Something is missing from the following declaration – what?

class Snakes
    def __init__():
        self.sound = 'Sssssss'


Check
The __init__() constructor lacks the obligatory parameter (we should name it self to stay compliant with the standards).



Exercise 3

Modify the code to guarantee that the venomous property is private.

class Snakes
    def __init__(self):
        self.venomous = True


Check
The code should look as follows:

class Snakes
    def __init__(self):
        self.__venomous = True


12.
https://edube.org/learn/pe-2/oop-properties-24








