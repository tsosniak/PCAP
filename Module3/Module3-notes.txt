https://edube.org/learn/pe-2/python-essentials-2-module-3-1

1. The basic concepts of the object-oriented approach

This kind of understanding of a project's structure makes many important tasks easier, e.g., dividing the project into small, independent parts, and independent development of different project elements.

Python is a universal tool for both object and procedural programming.


2. Procedural vs. the object-oriented approach
In the procedural approach, it's possible to distinguish two different and completely separate worlds: the world of data, and the world of code.
The world of data is populated with variables of different kinds, while the world of code is inhabited by code grouped into modules and functions.
Functions are able to use data, but not vice versa.

The object approach suggests a completely different way of thinking
The data and the code are enclosed together in the same world, divided into classes.
Every class is like a recipe which can be used when you want to create a useful object
All these concepts reflect real facts, relationships, and circumstances.

3. Class hierarchies
superclass, subclass

4. What is an object?
instance of class

5. Inheritance
Any object bound to a specific level of a class hierarchy inherits all the traits (as well as the requirements and qualities) defined inside any of the superclasses.

6. What does an object have?
object has a name that uniquely identifies it within its home namespace
object has a set of individual properties which make it original, unique or outstanding
object has a set of abilities to perform specific activities, able to change the object itself, or some of the other objects.

a noun - you probably define the object's name;
an adjective - you probably define the object's property;
a verb - you probably define the object's activity.

A pink Cadillac went quickly.

Object name = Cadillac
Home class = Wheeled vehicles
Property = Color (pink)
Activity = Go (quickly)

7. Object programming
Object programming is the art of defining and expanding classes.
A class is a model of a very specific part of reality, reflecting properties and activities found in the real world.

The classes defined at the beginning are too general and imprecise to cover the largest possible number of real cases.

There's no obstacle to defining new, more precise subclasses. They'll inherit everything from their superclass, so the work that went into its creation isn't wasted.

The new class may add new properties and new activities, and therefore may be more useful in specific applications. Obviously, it may be used as a superclass for any number of newly created subclasses.

The process doesn't need to have an end. You can create as many classes as you need.

class TheSimplestClass:
    pass

The class is rather poor: it has neither properties nor activities

The newly defined class becomes a tool that is able to create new objects.
The tool has to be used explicitly, on demand.

To do this, you need to assign a variable to store the newly created object of that class, and create an object at the same time.
my_first_object = TheSimplestClass()

The act of creating an object of the selected class is also called an instantiation (as the object becomes an instance of the class).

8.Key takeaways

1. A class is an idea (more or less abstract) which can be used to create a number of incarnations – such an incarnation is called an object.


2. When a class is derived from another class, their relation is named inheritance. The class which derives from the other class is named a subclass. The second side of this relation is named superclass. A way to present such a relation is an inheritance diagram, where:

superclasses are always presented above their subclasses;
relations between classes are shown as arrows directed from the subclass toward its superclass.

3. Objects are equipped with:

a name which identifies them and allows us to distinguish between them;
a set of properties (the set can be empty)
a set of methods (can be empty, too)

4. To define a Python class, you need to use the class keyword. For example:

class This_Is_A_Class:
     pass


5. To create an object of the previously defined class, you need to use the class as if it were a function. For example:

this_is_an_object = This_Is_A_Class()



Exercise 1

If we assume that pythons, vipers, and cobras are subclasses of the same superclass, how would you call it?

Check
Snake, reptile, vertebrate, animal – all these answers are acceptable.


Exercise 2

Try to name a few python class subclasses.

Check
Indian python, African rock python, ball python, Burmese python – the list is long.


Exercise 3

Can you name one of your classes just "class"?

Check
No, you can't – class is a keyword!


9. What is a stack?
A stack is a structure developed to store data in a very specific way
The alternative name for a stack (but only in IT terminology) is LIFO. Last In - First Out

!!! A stack is an object with two elementary operations, conventionally named push (when a new element is put on the top)
and pop (when an existing element is taken away from the top). !!!


The stack - the procedural approach
First, you have to decide how to store the values which will arrive onto the stack. We suggest using the simplest of methods, and employing a list for this job.

stack = []


def push(val):
    stack.append(val)


def pop():
    val = stack[-1]
    del stack[-1]
    return val


push(3)
push(2)
push(1)

print(pop())
print(pop())
print(pop())


The stack - the procedural approach vs. the object-oriented approach

disadvantages:
the essential variable (the stack list) is highly vulnerable; anyone can modify it in an uncontrollable way, destroying the stack, in effect;
it may also happen that one day you need more than one stack; you'll have to create another list for the stack's storage, and probably other push and pop functions too;
it may also happen that you need not only push and pop functions, but also some other conveniences; you could certainly implement them, but try to imagine what would happen if you had dozens of separately implemented stacks.

The objective approach delivers solutions for each of the above problems
the ability to hide (protect) selected values against unauthorized access is called encapsulation; the encapsulated values can be neither accessed nor modified if you want to use them exclusively;
you can produce as many stacks as you want; you needn't copy or replicate any part of the code;
the ability to enrich the stack with new functions comes from inheritance;

The stack - the object approach
def __init__(self) -> Such a function is called a constructor, as its general purpose is to construct a new object.

When any class component has a name starting with two underscores (__), it becomes private - this means that it can be accessed only from within the class.
You cannot see it from the outside world. This is how Python implements the encapsulation concept.

Such a component is called public, so you can't begin its name with two (or more) underscores. There is one more requirement - the name must have no more than one trailing underscore.

class Stack:
    def __init__(self):
        self.__stack_list = []


    def push(self, val):
        self.__stack_list.append(val)


    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


stack_object = Stack()

stack_object.push(3)
stack_object.push(2)
stack_object.push(1)

print(stack_object.pop())
print(stack_object.pop())
print(stack_object.pop())


!!! Here, both functions have a parameter named self at the first position of the parameters list. !!!
It allows the method to access entities (properties and activities/methods) carried out by the actual object. You cannot omit it.
Every time Python invokes a method, it implicitly sends the current object as the first argument.
This means that a method is obligated to have at least one parameter, which is used by Python itself


10. The object approach: a stack from scratch
Let's add a new class for handling stacks.
The new class should be able to evaluate the sum of all the elements currently stored on the stack.

We don't want to modify the previously defined stack.
: just define a new subclass pointing to the class which will be used as the superclass. - It gets all the components defined by its superclass

class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self)
        self.__sum = 0

Contrary to many other languages, Python forces you to explicitly invoke a superclass's constructor.
Omitting this point will have harmful effects - the object will be deprived of the __stack_list list. Such a stack will not function properly.

Note the syntax:

you specify the superclass's name (this is the class whose constructor you want to run)
you put a dot (.)after it;
you specify the name of the constructor;
you have to point to the object (the class's instance) which has to be initialized by the constructor - this is why you have to specify the argument and use the self variable here;

!!! note: invoking any method (including constructors) from outside the class never requires you to put the self argument at the argument's list
- invoking a method from within the class demands explicit usage of the self argument, and it has to be put first on the list.
!!!

class Stack:
    def __init__(self):
        self.__stack_list = []

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self)
        self.__sum = 0

    def get_sum(self):
        return self.__sum

    def push(self, val):
        self.__sum += val
        Stack.push(self, val)

    def pop(self):
        val = Stack.pop(self)
        self.__sum -= val
        return val


stack_object = AddingStack()


Note the way we've invoked the previous implementation of the push method (the one available in the superclass):

we have to specify the superclass's name; this is necessary in order to clearly indicate the class containing the method, to avoid confusing it with any other function of the same name;
we have to specify the target object and to pass it as the first argument (it's not implicitly added to the invocation in this context.)


11. Key takeaways

1. A stack is an object designed to store data using the LIFO model. The stack usually accomplishes at least two operations, named push() and pop().


2. Implementing the stack in a procedural model raises several problems which can be solved by the techniques offered by OOP (Object Oriented Programming):


3. A class method is actually a function declared inside the class and able to access all the class's components.


4. The part of the Python class responsible for creating new objects is called the constructor, and it's implemented as a method of the name __init__.


5. Each class method declaration must contain at least one parameter (always the first one) usually referred to as self, and is used by the objects to identify themselves.


6. If we want to hide any of a class's components from the outside world, we should start its name with __. Such components are called private.



Exercise 1

Assuming that there is a class named Snakes, write the very first line of the Python class declaration, expressing the fact that the new class is actually a subclass of Snake.

Check
class Python(Snakes):



Exercise 2

Something is missing from the following declaration – what?

class Snakes
    def __init__():
        self.sound = 'Sssssss'


Check
The __init__() constructor lacks the obligatory parameter (we should name it self to stay compliant with the standards).



Exercise 3

Modify the code to guarantee that the venomous property is private.

class Snakes
    def __init__(self):
        self.venomous = True


Check
The code should look as follows:

class Snakes
    def __init__(self):
        self.__venomous = True


12. Instance variables; __dict__
https://edube.org/learn/pe-2/oop-properties-24

In general, a class can be equipped with two different kinds of data to form a class's properties
This kind of class property exists when and only when it is explicitly created and added to an object.
this can be done during the object's initialization, performed by the constructor.
Moreover, it can be done in any moment of the object's life.

Such variables (properties) are called instance variables.
The word instance suggests that they are closely connected to the objects (which are class instances), not to the classes themselves.

Python objects, when created, are gifted with a small set of predefined properties and methods. Each object has got them,
 whether you want them or not. One of them is a variable named __dict__ (it's a dictionary).

__dict__ : The variable contains the names and values of all the properties (variables) the object is currently carrying


class ExampleClass:
    def __init__(self, val = 1):
        self.first = val

    def set_second(self, val):
        self.second = val


example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)

example_object_2.set_second(3)

example_object_3 = ExampleClass(4)
example_object_3.third = 5

print(example_object_1.__dict__)
print(example_object_2.__dict__)
print(example_object_3.__dict__)

>>>
{'first': 1}
{'second': 3, 'first': 2}
{'third': 5, 'first': 4}

ExampleClass has a constructor, which unconditionally creates an instance variable named first
the class also has a method which creates another instance variable, named second;

we've created three objects of the class ExampleClass, but all these instances differ:
example_object_1 only has the property named first;
example_object_2 has two properties: first and second;
example_object_3 has been enriched with a property named third just on the fly, outside the class's code - this is possible and fully permissible.

Note: modifying an instance variable of any object has no impact on all the remaining objects.
!!! Instance variables are perfectly isolated from each other. !!!

 two underscores (__)  - makes the instance variable private - it becomes inaccessible from the outer world.

!!!
class ExampleClass:
    def __init__(self, val = 1):
        self.__first = val

    def set_second(self, val = 2):
        self.__second = val

When Python sees that you want to add an instance variable to an object and you're going to do it inside any of
the object's methods, it mangles the operation in the following way:
it puts a class name before your name;
it puts an additional underscore at the beginning.

This is why the __first becomes _ExampleClass__first.
The name is now fully accessible from outside the class.
print(example_object_1._ExampleClass__first)

NOTE: The mangling won't work if you add a private instance variable outside the class code.
In this case, it'll behave like any other ordinary property.

!!!


13. Class variables
A class variable is a property which exists in just one copy and is stored outside any object.

Note: no instance variable exists if there is no object in the class; a class variable exists in one copy even if there are no objects in the class.

Class variables are created differently to their instance siblings.

class ExampleClass:
    counter = 0
    def __init__(self, val = 1):
        self.__first = val
        ExampleClass.counter += 1


example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)
example_object_3 = ExampleClass(4)

print(example_object_1.__dict__, example_object_1.counter)
print(example_object_2.__dict__, example_object_2.counter)
print(example_object_3.__dict__, example_object_3.counter)

>>>
{'_ExampleClass__first': 1} 3
{'_ExampleClass__first': 2} 3
{'_ExampleClass__first': 4} 3


!!! IMPORTANT !!!
class variables aren't shown in an object's __dict__ (this is natural as class variables aren't parts of an object)
but you can always try to look into the variable of the same name, but at the class level - we'll show you this very soon;
a class variable always presents the same value in all class instances (objects)

!!! Mangling a class variable's name has the same effects as those you're already familiar with. !!!

class ExampleClass:
    __counter = 0
    def __init__(self, val = 1):
        self.__first = val
        ExampleClass.__counter += 1


example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)
example_object_3 = ExampleClass(4)

print(example_object_1.__dict__, example_object_1._ExampleClass__counter)
print(example_object_2.__dict__, example_object_2._ExampleClass__counter)
print(example_object_3.__dict__, example_object_3._ExampleClass__counter)

>>>
{'_ExampleClass__first': 1} 3
{'_ExampleClass__first': 2} 3
{'_ExampleClass__first': 4} 3


14. __dict__ difference: class vs. object

Now we're going to take the opportunity to show you the difference between these two __dict__ variables,
the one from the class and the one from the object.

class ExampleClass:
    varia = 1
    def __init__(self, val):
        ExampleClass.varia = val


print(ExampleClass.__dict__)
example_object = ExampleClass(2)

print(ExampleClass.__dict__)
print(example_object.__dict__)

>>>
{'__module__': '__main__', 'varia': 1 ...
{'__module__': '__main__', 'varia': 2 ...
{}

Naming the variable is the most important aspect of the example because:
Changing the assignment to self.varia = val would create an instance variable of the same name as the class's one;
Changing the assignment to varia = val would operate on a !!! method's local variable !!!;
(we strongly encourage you to test both of the above cases - this will make it easier for you to remember the difference)

class' __dict__ contains much more data than its object's counterpart.
Note that the object's __dict__ is empty - the object has no instance variables.


15. Checking an attribute's existence
Python's attitude to object instantiation raises one important issue:
you may not expect that all objects of the same class have the same sets of properties.

class ExampleClass:
    def __init__(self, val):
        if val % 2 != 0:
            self.a = 1
        else:
            self.b = 1


example_object = ExampleClass(1)

print(example_object.a)
print(example_object.b)

>>>
1
Traceback (most recent call last):
  File ".main.py", line 11, in
    print(example_object.b)
AttributeError: 'ExampleClass' object has no attribute 'b'

!!! As you can see, accessing a non-existing object (class) attribute causes an AttributeError exception. !!!

16. hasattr
Python provides a function which is able to safely check if any object/class contains a specified property.

hasattr expects two arguments to be passed to it:
the class or the object being checked;
the name of the property whose existence has to be reported (note: it has to be a string containing the attribute name, not the name alone)
The function returns True or False.

if hasattr(example_object, 'b'):
    print(example_object.b)

Note: better solution than try.. catch..

hasattr() function can operate on classes, too.
You can use it to find out if a class variable is available

!!!

class ExampleClass:
    a = 1
    def __init__(self):
        self.b = 2


example_object = ExampleClass()

print(hasattr(example_object, 'b'))
print(hasattr(example_object, 'a'))
print(hasattr(ExampleClass, 'b'))
print(hasattr(ExampleClass, 'a'))

>>>
True
True
False
True

!!!

17. Key takeaways

1. An instance variable is a property whose existence depends on the creation of an object. Every object can have a different set of instance variables.

Moreover, they can be freely added to and removed from objects during their lifetime. All object instance variables are stored inside a dedicated dictionary named __dict__, contained in every object separately.


2. An instance variable can be private when its name starts with __, but don't forget that such a property is still accessible from outside the class using a mangled name constructed as _ClassName__PrivatePropertyName.


3. A class variable is a property which exists in exactly one copy, and doesn't need any created object to be accessible. Such variables are not shown as __dict__ content.

All a class's class variables are stored inside a dedicated dictionary named __dict__, contained in every class separately.


4. A function named hasattr() can be used to determine if any object/class contains a specified property.

For example:

class Sample:
    gamma = 0 # Class variable.
    def __init__(self):
        self.alpha = 1 # Instance variable.
        self.__delta = 3 # Private instance variable.


obj = Sample()
obj.beta = 2  # Another instance variable (existing only inside the "obj" instance.)
print(obj.__dict__)


The code outputs:

{'alpha': 1, '_Sample__delta': 3, 'beta': 2}
output



Exercise 1

Which of the Python class properties are instance variables and which are class variables? Which of them are private?

class Python:
    population = 1
    victims = 0
    def __init__(self):
        self.length_ft = 3
        self.__venomous = False

Check
population and victims are class variables, while length and __venomous are instance variables (the latter is also private).



Exercise 2

You're going to negate the __venomous property of the version_2 object, ignoring the fact that the property is private. How will you do this?

version_2 = Python()


Check
version_2._Python__venomous = not version_2._Python__venomous



Exercise 3

Write an expression which checks if the version_2 object contains an instance property named constrictor (yes, constrictor!).

Check
hasattr(version_2, 'constrictor')

18.
https://edube.org/learn/pe-2/section-summary-102

18. Methods in detail
method is a function embedded inside a class.
a method is obliged to have at least one parameter (self)

The name self suggests the parameter's purpose - it identifies the object for which the method is invoked.

If you're going to invoke a method, you mustn't pass the argument for the self parameter - Python will set it for you.

The self parameter is used to obtain access to the object's instance and class variables.

class Classy:
    varia = 2
    def method(self):
        print(self.varia, self.var)

The self parameter is also used to invoke other object/class methods from inside the class.

class Classy:
    def other(self):
        print("other")

    def method(self):
        print("method")
        self.other()


__init__
If a class has a constructor, it is invoked automatically and implicitly when the object of the class is instantiated.

The constructor:

is obliged to have the self parameter (it's set automatically, as usual);
may (but doesn't need to) have more parameters than just self; if this happens, the way in which the class name is used
to create the object must reflect the __init__ definition;
can be used to set up the object, i.e., properly initialize its internal state, create instance variables, instantiate
any other objects if their existence is needed, etc.

Note that the constructor:

cannot return a value, as it is designed to return a newly created object and nothing else;
cannot be invoked directly either from the object or from inside the class

property name mangling applies to method names, too

class Classy:
    def visible(self):
        print("visible")

    def __hidden(self):
        print("hidden")


obj = Classy()
obj.visible()

try:
    obj.__hidden()
except:
    print("failed")

obj._Classy__hidden()


19. The inner life of classes and objects
__dict__ is a dictionary. Another built-in property worth mentioning is __name__, which is a string.

Note: the __name__ attribute is absent from the object - it exists only inside classes.

class Classy:
    pass


print(Classy.__name__)
obj = Classy()
print(type(obj).__name__)
print(obj.__name__)

>>>
Classy
Classy
Traceback (most recent call last):
  File "main.py", line 8, in <module>
    print(obj.__name__)
AttributeError: 'Classy' object has no attribute '__name__'


If you want to find the class of a particular object, you can use a function named type(),
which is able (among other things) to find a class which has been used to instantiate any object.

20.The inner life of classes and objects: continued
__module__ is a string, too - it stores the name of the module which contains the definition of the class.

class Classy:
    pass


print(Classy.__module__)
obj = Classy()
print(obj.__module__)

>>>
__main__
__main__


21. The inner life of classes and objects: continued
__bases__ is a tuple. The tuple contains classes (not class names) which are direct superclasses for the class.
The order is the same as that used inside the class definition.

!!! Note: only classes have this attribute - objects don't. !!!


22. Reflection and introspection

introspection, which is the ability of a program to examine the type or properties of an object at runtime;
reflection, which goes a step further, and is the ability of a program to manipulate the values, properties and/or functions of an object at runtime.

In other words, you don't have to know a complete class/object definition to manipulate the object, as the object and/or
its class contain the metadata allowing you to recognize its features during program execution.

23. Investigating classes

The function named incIntsI() gets an object of any class, scans its contents in order to find all integer
attributes with names starting with i, and increments them by one.

class MyClass:
    pass

obj = MyClass()
obj.a = 1
obj.b = 2
obj.i = 3
obj.ireal = 3.5
obj.integer = 4
obj.z = 5


def incIntsI(obj):
    for name in obj.__dict__.keys():
        if name.startswith('i'):
            val = getattr(obj, name)
            if isinstance(val, int):
                setattr(obj, name, val + 1)


print(obj.__dict__)
incIntsI(obj)
print(obj.__dict__)

>>>
{'a': 1, 'b': 2, 'i': 3, 'ireal': 3.5, 'integer': 4, 'z': 5}
{'a': 1, 'b': 2, 'i': 4, 'ireal': 3.5, 'integer': 5, 'z': 5}

24. Key takeaways

1. A method is a function embedded inside a class. The first (or only) parameter of each method is usually named self, which is designed to identify the object for which the method is invoked in order to access the object's properties or invoke its methods.


2. If a class contains a constructor (a method named __init__) it cannot return any value and cannot be invoked directly.


3. All classes (but not objects) contain a property named __name__, which stores the name of the class. Additionally, a property named __module__ stores the name of the module in which the class has been declared, while the property named __bases__ is a tuple containing a class's superclasses.

For example:

class Sample:
    def __init__(self):
        self.name = Sample.__name__
    def myself(self):
        print("My name is " + self.name + " living in a " + Sample.__module__)


obj = Sample()
obj.myself()


The code outputs:

My name is Sample living in a __main__
output



Exercise 1

The declaration of the Snake class is given below. Enrich the class with a method named increment(), adding 1 to the __victims property.

class Snake:
    def __init__(self):
        self.victims = 0

Check
class Snake:
    def __init__(self):
        self.victims = 0

    def increment(self):
        self.victims += 1




Exercise 2

Redefine the Snake class constructor so that is has a parameter to initialize the victims field with a value passed to the object during construction.


Check
class Snake:
    def __init__(self, victims):
        self.victims = victims



Exercise 3

Can you predict the output of the following code?

class Snake:
    pass


class Python(Snake):
    pass


print(Python.__name__, 'is a', Snake.__name__)
print(Python.__bases__[0].__name__, 'can be', Python.__name__)


Check
Python is a Snake
Snake can be Python


25. Inheritance - why and how?

The default __str__() method returns the previous string - ugly and not very informative. You can change it just by defining your own method of the name.

class Star:
    def __init__(self, name, galaxy):
        self.name = name
        self.galaxy = galaxy

    def __str__(self):
        return self.name + ' in ' + self.galaxy


sun = Star("Sun", "Milky Way")
print(sun)


Inheritance is a common practice (in object programming) of passing attributes and methods from the superclass (defined
and existing) to a newly created class, called the subclass.

In other words, inheritance is a way of building a new class, not from scratch, but by using an already defined repertoire of traits.

The new class inherits (and this is the key) all the already existing equipment, but is able to add some new ones if needed.

Thanks to that, it's possible to build more specialized (more concrete) classes using some sets of predefined general rules and behaviors

superclass / subclass


26. issubclass()
able to identify a relationship between two classes,
it can check if a particular class is a subclass of any other class.

issubclass(ClassOne, ClassTwo)

Note: each class is considered to be a subclass of itself.
Note2: only works on classes!!! not objects (TypeError)

27. isinstance()
an object is an incarnation of a class
whether it is an object of a certain class or not.

isinstance(objectName, ClassName)

first arg can be object, 2nd arg must BE class (type) - otherwise TypeError

Being an instance of a class means that the object (the cake) has been prepared using a recipe contained in either the class or one of its superclasses.


28. Inheritance: the is operator
The is operator checks whether two variables (object_one and object_two here) refer to the same object.

!!! variables don't store the objects themselves, but only the handles pointing to the internal Python memory.!!!
!!! Assigning a value of an object variable to another variable doesn't copy the object, but only its handle. !!!

29. How Python finds properties and methods

Note: As there is no __str__() method within the Sub class, the printed string is to be produced within the Super class.
This means that the __str__() method has been inherited by the Sub class.

class Super:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return "My name is " + self.name + "."


class Sub(Super):
    def __init__(self, name):
        Super.__init__(self, name)


obj = Sub("Andy")

print(obj)

>>>
My name is Andy.

https://edube.org/learn/pe-2/oop-fundamentals-inheritance-64









